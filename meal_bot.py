#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Meal Prep Bot V2.0 - Sistema completo con perfiles individuales y IA integrada
Integra todos los sistemas nuevos: categor√≠as duales, Available Energy, generaci√≥n IA
"""

import json
import os
import logging
import fcntl
import atexit
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple

import telebot
from telebot import types
from anthropic import Anthropic
from flask import Flask, request

# Importar nuevos sistemas
from user_profile_system import UserProfileSystem
from claude_prompt_system import ClaudePromptSystem
from recipe_validator import RecipeValidator
from ai_integration import AIRecipeGenerator, format_recipe_for_display
from menu_display_system import format_menu_for_telegram
from shopping_list_generator import ShoppingListGenerator
from weekly_planner import WeeklyPlanner
from recipe_intelligence import RecipeIntelligence
from progress_tracker import ProgressTracker
from meal_prep_scheduler import MealPrepScheduler
from nutrition_analytics import NutritionAnalytics
from weekly_menu_system import WeeklyMenuSystem

from config import (
    TELEGRAM_TOKEN, ANTHROPIC_API_KEY, WEBHOOK_URL, WEBHOOK_PATH, USE_WEBHOOK
)

# Configurar logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Inicializar componentes
bot = telebot.TeleBot(TELEGRAM_TOKEN)
app = Flask(__name__)

# Inicializar Claude client
try:
    claude_client = Anthropic(api_key=ANTHROPIC_API_KEY)
    logger.info("‚úÖ Claude client initialized successfully")
except Exception as e:
    logger.error(f"‚ùå Error initializing Claude client: {e}")
    claude_client = None

class MealPrepBotV2:
    def __init__(self):
        self.database_file = "recipes_new.json"
        self.data = self.load_data()
        
        # Inicializar sistemas
        self.profile_system = UserProfileSystem(self.database_file)
        self.prompt_system = ClaudePromptSystem()
        self.validator = RecipeValidator()
        self.shopping_generator = ShoppingListGenerator()
        self.weekly_planner = WeeklyPlanner()
        self.recipe_intelligence = RecipeIntelligence()
        self.progress_tracker = ProgressTracker()
        self.meal_prep_scheduler = MealPrepScheduler()
        self.nutrition_analytics = NutritionAnalytics()
        self.weekly_menu_system = WeeklyMenuSystem(self.database_file)
        self.ai_generator = AIRecipeGenerator(
            ANTHROPIC_API_KEY, 
            self.prompt_system, 
            self.validator
        )
        
        # Estado de conversaci√≥n por usuario
        self.user_states = {}
        
        logger.info("üöÄ MealPrepBot V2.0 initialized with new architecture")
    
    def load_data(self) -> Dict:
        """Cargar datos de la nueva estructura"""
        try:
            with open(self.database_file, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            logger.error(f"No se encontr√≥ {self.database_file}")
            return self.create_default_data()
        except json.JSONDecodeError:
            logger.error(f"Error al leer {self.database_file}")
            return self.create_default_data()
    
    def create_default_data(self) -> Dict:
        """Crear estructura de datos nueva"""
        with open("recipes_new.json", 'r', encoding='utf-8') as f:
            return json.load(f)
    
    def save_data(self) -> bool:
        """Guardar datos con backup autom√°tico"""
        try:
            # Crear backup
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            backup_file = f"backup_v2_{timestamp}.json"
            
            if os.path.exists(self.database_file):
                with open(self.database_file, 'r', encoding='utf-8') as f:
                    backup_data = json.load(f)
                with open(backup_file, 'w', encoding='utf-8') as f:
                    json.dump(backup_data, f, ensure_ascii=False, indent=2)
            
            # Guardar datos actuales
            with open(self.database_file, 'w', encoding='utf-8') as f:
                json.dump(self.data, f, ensure_ascii=False, indent=2)
            
            return True
        except Exception as e:
            logger.error(f"Error al guardar datos: {e}")
            return False
    
    def get_user_profile(self, telegram_id: str) -> Optional[Dict]:
        """Obtener perfil de usuario por Telegram ID"""
        return self.data["users"].get(telegram_id)
    
    def save_generated_recipe(self, telegram_id: str, recipe: Dict, timing_category: str, validation: Dict) -> bool:
        """Guardar receta generada en el perfil del usuario"""
        try:
            user_profile = self.get_user_profile(telegram_id)
            if not user_profile:
                return False
            
            # Inicializar lista de recetas si no existe
            if "generated_recipes" not in user_profile:
                user_profile["generated_recipes"] = []
            
            # Crear entrada de receta con metadata
            recipe_entry = {
                "id": f"{telegram_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                "generated_date": datetime.now().isoformat(),
                "timing_category": timing_category,
                "recipe_data": recipe,
                "validation_score": validation.get("score", 0),
                "user_rating": None  # Para futuras mejoras
            }
            
            # Agregar al inicio de la lista (m√°s reciente primero)
            user_profile["generated_recipes"].insert(0, recipe_entry)
            
            # Mantener solo las √∫ltimas 20 recetas por usuario
            if len(user_profile["generated_recipes"]) > 20:
                user_profile["generated_recipes"] = user_profile["generated_recipes"][:20]
            
            # Tambi√©n guardar en recent_generated_recipes para sistema de valoraci√≥n
            if "recent_generated_recipes" not in user_profile:
                user_profile["recent_generated_recipes"] = []
            
            # Agregar receta con ID √∫nico para valoraci√≥n
            recipe_for_rating = recipe.copy()
            recipe_for_rating["recipe_id"] = recipe_entry["id"]
            recipe_for_rating["generated_at"] = recipe_entry["generated_date"]
            
            user_profile["recent_generated_recipes"].append(recipe_for_rating)
            
            # Mantener solo las √∫ltimas 10 recetas para valoraci√≥n
            if len(user_profile["recent_generated_recipes"]) > 10:
                user_profile["recent_generated_recipes"] = user_profile["recent_generated_recipes"][-10:]
            
            # Guardar cambios
            self.data["users"][telegram_id] = user_profile
            return self.save_data()
            
        except Exception as e:
            logger.error(f"Error saving generated recipe for user {telegram_id}: {e}")
            return False
    
    def create_user_if_not_exists(self, telegram_id: str, message) -> bool:
        """Crear usuario si no existe y redirigir a setup de perfil"""
        if telegram_id not in self.data["users"]:
            bot.send_message(
                message.chat.id,
                "üëã ¬°Bienvenido al Meal Prep Bot V2.0!\n\n"
                "Para comenzar, necesito configurar tu perfil nutricional personalizado.\n"
                "Usa el comando /perfil para empezar.",
                reply_markup=self.create_main_menu_keyboard()
            )
            return False
        return True
    
    def create_main_menu_keyboard(self) -> types.ReplyKeyboardMarkup:
        """Crear teclado principal con comandos disponibles"""
        keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
        
        buttons = [
            "/perfil", "/mis_macros",
            "/menu", "/recetas", 
            "/complementos", "/buscar",
            "/generar", "/nueva_semana"
        ]
        
        keyboard.add(*[types.KeyboardButton(btn) for btn in buttons])
        return keyboard
    
    def split_long_message(self, text: str, max_length: int = 4000) -> List[str]:
        """Dividir mensajes largos para Telegram (l√≠mite 4096 caracteres)"""
        if len(text) <= max_length:
            return [text]
        
        messages = []
        current_message = ""
        
        lines = text.split('\n')
        for line in lines:
            if len(current_message + line + '\n') <= max_length:
                current_message += line + '\n'
            else:
                if current_message:
                    messages.append(current_message.strip())
                current_message = line + '\n'
        
        if current_message:
            messages.append(current_message.strip())
        
        return messages
    
    def send_long_message(self, chat_id: int, text: str, **kwargs):
        """Enviar mensaje largo dividi√©ndolo si es necesario"""
        messages = self.split_long_message(text)
        for i, msg in enumerate(messages):
            if i == 0:
                bot.send_message(chat_id, msg, **kwargs)
            else:
                bot.send_message(chat_id, msg, parse_mode=kwargs.get('parse_mode'))

# Crear instancia global del bot
meal_bot = MealPrepBotV2()

# ========================================
# COMANDOS PRINCIPALES
# ========================================

@bot.message_handler(commands=['start'])
def start_command(message):
    """Comando de inicio con personalizaci√≥n visual"""
    telegram_id = str(message.from_user.id)
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    if user_profile:
        # Usuario existente - bienvenida personalizada
        preferences = user_profile.get("preferences", {})
        liked_count = len(preferences.get("liked_foods", []))
        disliked_count = len(preferences.get("disliked_foods", []))
        
        welcome_text = f"""
‚ú® **¬°Bienvenido de vuelta!** Meal Prep Bot V2.0

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
üéØ **Personalizaci√≥n:** {liked_count} preferencias, {disliked_count} exclusiones
üî• **Calor√≠as objetivo:** {user_profile['macros']['calories']} kcal/d√≠a
‚ö° **Available Energy:** {user_profile['energy_data']['available_energy']} kcal/kg FFM/d√≠a

üöÄ **SISTEMA COMPLETAMENTE PERSONALIZADO:**

‚úÖ **Men√∫s:** Adaptados a tus gustos y objetivo
‚úÖ **Recetas IA:** Generadas espec√≠ficamente para ti  
‚úÖ **Listas de compra:** Optimizadas para tu perfil
‚úÖ **Complementos:** Filtrados seg√∫n preferencias
‚úÖ **Favoritas:** Sistema de recetas guardadas

**COMANDOS PRINCIPALES:**
üéØ /mis_macros - Tus macros personalizados
üìÖ /menu - Men√∫ semanal con tus preferencias
üõí /lista_compras - Lista optimizada para ti
‚≠ê /favoritas - Tus recetas guardadas
ü§ñ /generar - Crear recetas para tu objetivo
üåü /valorar - Valorar recetas con 1-5 estrellas
üåü /valorar_receta - Entrenar IA con ratings

**CONFIGURACI√ìN:**
‚öôÔ∏è /editar_perfil - Modificar preferencias
üìÖ /nueva_semana - Configurar cronograma

üí° **Todo se adapta autom√°ticamente a tu perfil nutricional**
"""
    else:
        # Nuevo usuario
        welcome_text = """
üçΩÔ∏è **¬°Bienvenido al Meal Prep Bot V2.0!**

ü§ñ **Sistema de meal prep con IA completamente personalizado**

**¬øQu√© puedo hacer por ti?**
üìä Calcular macros seg√∫n tu objetivo espec√≠fico
üçΩÔ∏è Crear men√∫s adaptados a tus preferencias
ü§ñ Generar recetas con IA para tu perfil
üõí Listas de compra optimizadas autom√°ticamente
‚≠ê Sistema de recetas favoritas personalizado

‚ö†Ô∏è **IMPORTANTE:** Para experiencia 100% personalizada:

üÜï **Paso 1:** Usa `/perfil` para configurar tu perfil
üéØ **Paso 2:** El sistema se adaptar√° autom√°ticamente a ti
‚ú® **Resultado:** Men√∫s, recetas y listas personalizadas

**COMANDOS B√ÅSICOS (sin personalizar):**
/perfil - ¬°Empieza aqu√≠ para personalizaci√≥n completa!
/menu - Men√∫ gen√©rico
/recetas - Ver recetas b√°sicas
/buscar [consulta] - Buscar recetas con IA

üí° **¬°Configura tu perfil para experiencia personalizada al 100%!**
"""
    
    meal_bot.send_long_message(message.chat.id, welcome_text, parse_mode='Markdown')

@bot.message_handler(commands=['perfil'])
def perfil_command(message):
    """Comando para configurar perfil de usuario"""
    telegram_id = str(message.from_user.id)
    
    # Iniciar proceso de configuraci√≥n de perfil
    meal_bot.user_states[telegram_id] = {
        "state": "profile_setup",
        "step": "enfoque_dietetico",
        "data": {}
    }
    
    # Crear teclado para enfoque diet√©tico
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    keyboard.add(
        types.InlineKeyboardButton("üá™üá∏ Tradicional Espa√±ol - Platos equilibrados, ingredientes mediterr√°neos", callback_data="approach_tradicional"),
        types.InlineKeyboardButton("üí™ Fitness Orientado - Optimizaci√≥n nutricional, macros precisos", callback_data="approach_fitness")
    )
    
    bot.send_message(
        message.chat.id,
        "üë§ **CONFIGURACI√ìN DE PERFIL NUTRICIONAL**\n\n"
        "Antes de calcular tus macros personalizados, necesito conocer tu enfoque preferido:\n\n"
        "üçΩÔ∏è **¬øQu√© enfoque nutricional prefieres?**\n\n"
        "**üá™üá∏ Tradicional Espa√±ol:**\n"
        "‚Ä¢ Platos mediterr√°neos equilibrados\n"
        "‚Ä¢ Ingredientes locales y de temporada\n"
        "‚Ä¢ Recetas familiares y culturales\n"
        "‚Ä¢ Enfoque en sabor y tradici√≥n\n\n"
        "**üí™ Fitness Orientado:**\n"
        "‚Ä¢ Optimizaci√≥n de macronutrientes\n"
        "‚Ä¢ Timing nutricional preciso\n"
        "‚Ä¢ Maximizaci√≥n de resultados deportivos\n"
        "‚Ä¢ Enfoque cient√≠fico y medible\n\n"
        "üìç _Esta elecci√≥n influir√° en el tipo de recetas y recomendaciones que recibir√°s_",
        parse_mode='Markdown',
        reply_markup=keyboard
    )

@bot.message_handler(commands=['mis_macros'])
def mis_macros_command(message):
    """Mostrar macros calculados del usuario"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Datos del perfil
    basic_data = user_profile["basic_data"]
    body_comp = user_profile["body_composition"]
    energy_data = user_profile["energy_data"]
    macros = user_profile["macros"]
    preferences = user_profile.get("preferences", {})
    exercise_profile = user_profile.get("exercise_profile", {})
    
    # Formatear preferencias alimentarias
    liked_foods = preferences.get("liked_foods", [])
    disliked_foods = preferences.get("disliked_foods", [])
    cooking_methods = preferences.get("cooking_methods", [])
    
    # Formatear listas de preferencias con emojis
    def format_food_list(food_list):
        if not food_list:
            return "Ninguna especificada"
        
        food_emojis = {
            "carnes_rojas": "ü•©", "aves": "üêî", "pescados": "üêü", "huevos": "ü•ö",
            "lacteos": "ü•õ", "frutos_secos": "ü•ú", "legumbres": "ü´ò", "hojas_verdes": "ü•¨",
            "cruciferas": "ü•¶", "solanaceas": "üçÖ", "aromaticas": "üåø", "raices": "ü•ï",
            "pimientos": "üå∂Ô∏è", "pepinaceas": "ü•í", "aceitunas": "ü´í", "aguacate": "ü•ë"
        }
        
        formatted = []
        for food in food_list:
            emoji = food_emojis.get(food, "üçΩÔ∏è")
            name = food.replace("_", " ").title()
            formatted.append(f"{emoji} {name}")
        
        return ", ".join(formatted)
    
    def format_cooking_methods(methods_list):
        if not methods_list:
            return "Ninguno especificado"
            
        method_emojis = {
            "horno": "üî•", "sarten": "üç≥", "plancha": "ü•ò", "vapor": "ü´ï",
            "crudo": "ü•ó", "guisado": "üç≤", "parrilla": "üî•", "hervido": "ü•Ñ"
        }
        
        formatted = []
        for method in methods_list:
            emoji = method_emojis.get(method, "üë®‚Äçüç≥")
            name = method.replace("_", " ").title()
            formatted.append(f"{emoji} {name}")
        
        return ", ".join(formatted)
    
    response_text = f"""
üë§ **TU PERFIL NUTRICIONAL COMPLETO**

**DATOS B√ÅSICOS:**
‚Ä¢ Peso: {basic_data['peso']} kg
‚Ä¢ Altura: {basic_data['altura']} cm
‚Ä¢ Edad: {basic_data['edad']} a√±os
‚Ä¢ Objetivo: {basic_data['objetivo_descripcion']}

**COMPOSICI√ìN CORPORAL:**
‚Ä¢ BMR: {body_comp['bmr']} kcal/d√≠a
‚Ä¢ Grasa corporal: {body_comp['body_fat_percentage']}%
‚Ä¢ Masa magra: {body_comp['lean_mass_kg']} kg
‚Ä¢ IMC: {body_comp['bmi']}

**ENERG√çA DISPONIBLE:**
‚Ä¢ Available Energy: {energy_data['available_energy']} kcal/kg FFM/d√≠a
‚Ä¢ Estado: {energy_data['ea_status']['color']} {energy_data['ea_status']['description']}
‚Ä¢ TDEE: {energy_data['tdee']} kcal/d√≠a
‚Ä¢ Ejercicio diario: {energy_data['daily_exercise_calories']} kcal

**MACROS DIARIOS OBJETIVO:**
ü•© Prote√≠na: {macros['protein_g']}g ({macros['protein_g']*4} kcal)
üçû Carbohidratos: {macros['carbs_g']}g ({macros['carbs_g']*4} kcal)
ü•ë Grasas: {macros['fat_g']}g ({macros['fat_g']*9} kcal)
üî• **TOTAL: {macros['calories']} kcal/d√≠a**

**TUS PREFERENCIAS PERSONALES:**
üçΩÔ∏è **Alimentos preferidos:**
{format_food_list(liked_foods)}

üö´ **Alimentos a evitar:**
{format_food_list(disliked_foods)}

üë®‚Äçüç≥ **M√©todos de cocci√≥n preferidos:**
{format_cooking_methods(cooking_methods)}

‚è∞ **Horario de entrenamiento:**
{exercise_profile.get('training_schedule_desc', 'No especificado')}

**RECOMENDACI√ìN PERSONALIZADA:**
{energy_data['ea_status']['recommendation']}

üí° **Personalizaci√≥n activa:**
‚úÖ Tus preferencias se aplican en `/buscar` y `/generar`
‚úÖ Usa `/editar_perfil` para modificar tus preferencias
‚úÖ Comandos personalizados: `/menu`, `/complementos`
"""
    
    meal_bot.send_long_message(message.chat.id, response_text, parse_mode='Markdown')

@bot.message_handler(commands=['editar_perfil'])
def editar_perfil_command(message):
    """Comando para editar preferencias del perfil existente"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    if not user_profile:
        bot.send_message(
            message.chat.id,
            "‚ùå No tienes un perfil configurado.\n\n"
            "Usa `/perfil` para crear tu perfil primero.",
            parse_mode='Markdown'
        )
        return
    
    # Crear teclado de opciones de edici√≥n
    markup = types.InlineKeyboardMarkup(row_width=1)
    
    # Botones para cada secci√≥n editable
    markup.add(
        types.InlineKeyboardButton("üçΩÔ∏è Alimentos Preferidos", callback_data="edit_liked_foods"),
        types.InlineKeyboardButton("üö´ Alimentos a Evitar", callback_data="edit_disliked_foods"),
        types.InlineKeyboardButton("üë®‚Äçüç≥ M√©todos de Cocci√≥n", callback_data="edit_cooking_methods"),
        types.InlineKeyboardButton("‚è∞ Horario de Entrenamiento", callback_data="edit_training_schedule"),
        types.InlineKeyboardButton("‚ùå Cancelar", callback_data="cancel_edit")
    )
    
    # Obtener preferencias actuales
    preferences = user_profile.get("preferences", {})
    exercise_profile = user_profile.get("exercise_profile", {})
    
    current_preferences = f"""
üìù **TUS PREFERENCIAS ACTUALES:**

üçΩÔ∏è **Alimentos preferidos:**
{', '.join(preferences.get('liked_foods', [])) if preferences.get('liked_foods') else 'Ninguno seleccionado'}

üö´ **Alimentos a evitar:**
{', '.join(preferences.get('disliked_foods', [])) if preferences.get('disliked_foods') else 'Ninguno seleccionado'}

üë®‚Äçüç≥ **M√©todos de cocci√≥n:**
{', '.join(preferences.get('cooking_methods', [])) if preferences.get('cooking_methods') else 'Ninguno seleccionado'}

‚è∞ **Horario de entrenamiento:**
{exercise_profile.get('training_schedule_desc', 'No especificado')}

**¬øQu√© quieres modificar?**
"""
    
    bot.send_message(
        message.chat.id,
        current_preferences,
        parse_mode='Markdown',
        reply_markup=markup
    )

@bot.message_handler(commands=['menu'])
def menu_command(message):
    """Mostrar men√∫ semanal con timing nutricional"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Generar men√∫ con timing nutricional
    try:
        menu_text = format_menu_for_telegram(user_profile)
        meal_bot.send_long_message(message.chat.id, menu_text, parse_mode='Markdown')
        
    except Exception as e:
        logger.error(f"Error generating menu: {e}")
        
        # Fallback a men√∫ b√°sico
        fallback_text = f"""
üìÖ **MEN√ö SEMANAL PERSONALIZADO**

üéØ **Objetivo:** {user_profile['basic_data']['objetivo_descripcion']}
üî• **Calor√≠as diarias:** {user_profile['macros']['calories']} kcal
‚ö° **Available Energy:** {user_profile['energy_data']['available_energy']} kcal/kg FFM/d√≠a

**TIMING NUTRICIONAL OPTIMIZADO:**

üåÖ **DESAYUNO Y PRE-ENTRENO:**
‚Ä¢ Energ√≠a r√°pida para entrenar
‚Ä¢ Carbohidratos de absorci√≥n r√°pida

üçΩÔ∏è **ALMUERZO Y POST-ENTRENO:**
‚Ä¢ Prote√≠na para recuperaci√≥n muscular
‚Ä¢ Reposici√≥n de gluc√≥geno

üåô **CENA:**
‚Ä¢ Comida balanceada
‚Ä¢ Preparaci√≥n para descanso

ü•ú **COMPLEMENTOS MEDITERR√ÅNEOS:**
‚Ä¢ Distribuidos durante el d√≠a
‚Ä¢ Completan macros faltantes

**Para generar tu men√∫ espec√≠fico:**
‚Ä¢ /generar - Crear recetas por timing
‚Ä¢ /buscar [plato] - Encontrar recetas espec√≠ficas
‚Ä¢ /nueva_semana - Configurar rotaci√≥n completa
‚Ä¢ /valorar - Valorar recetas con 1-5 estrellas  
‚Ä¢ /valorar_receta - Entrenar IA con tus preferencias
"""
        
        meal_bot.send_long_message(message.chat.id, fallback_text, parse_mode='Markdown')

@bot.message_handler(commands=['configurar_menu'])
def configurar_menu_command(message):
    """Configurar men√∫ semanal personalizado con recetas guardadas"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Obtener recetas guardadas por categor√≠a
    recipes_by_category = meal_bot.weekly_menu_system.get_user_saved_recipes(user_profile)
    
    # Verificar si tiene recetas guardadas
    total_recipes = sum(len(recipes) for recipes in recipes_by_category.values())
    
    if total_recipes == 0:
        bot.send_message(
            message.chat.id,
            "ü§ñ **CONFIGURAR MEN√ö SEMANAL**\n\n"
            "‚ùå **No tienes recetas guardadas a√∫n.**\n\n"
            "Para configurar tu men√∫ semanal necesitas generar y guardar recetas primero:\n\n"
            "üìù **Pasos para empezar:**\n"
            "1. Usa `/generar` para crear recetas por categor√≠a\n"
            "2. Selecciona y guarda las recetas que te gusten\n"
            "3. Regresa a `/configurar_menu` para armar tu semana\n\n"
            "üí° **Tip:** Con al menos 1-2 recetas por comida podr√°s crear tu men√∫ personalizado.",
            parse_mode='Markdown'
        )
        return
    
    # Inicializar estado de configuraci√≥n de men√∫
    meal_bot.user_states[telegram_id] = {
        "state": "menu_configuration",
        "step": "category_selection",
        "data": {
            "selected_recipes": {"desayuno": [], "almuerzo": [], "merienda": [], "cena": []},
            "current_category": "desayuno"
        }
    }
    
    # Mostrar resumen de recetas disponibles
    summary_text = f"""
ü§ñ **CONFIGURAR MEN√ö SEMANAL PERSONALIZADO**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
üéØ **Enfoque:** {user_profile['basic_data'].get('enfoque_dietetico', 'fitness').title()}

üìä **Recetas disponibles:**
üåÖ **Desayuno:** {len(recipes_by_category['desayuno'])} recetas
üçΩÔ∏è **Almuerzo:** {len(recipes_by_category['almuerzo'])} recetas  
ü•ú **Merienda:** {len(recipes_by_category['merienda'])} recetas
üåô **Cena:** {len(recipes_by_category['cena'])} recetas

**Total:** {total_recipes} recetas guardadas

üîÑ **Proceso de configuraci√≥n:**
1. **Seleccionar recetas** por cada categor√≠a de comida
2. **Preview del men√∫** semanal generado autom√°ticamente
3. **Confirmar o editar** antes de aplicar

‚û°Ô∏è **Comenzaremos con el DESAYUNO**
"""
    
    bot.send_message(message.chat.id, summary_text, parse_mode='Markdown')
    
    # Mostrar recetas de desayuno para selecci√≥n
    show_category_recipe_selection(telegram_id, "desayuno", user_profile)

def show_category_recipe_selection(telegram_id: str, category: str, user_profile: Dict):
    """Mostrar interface de selecci√≥n de recetas para una categor√≠a"""
    recipes_by_category = meal_bot.weekly_menu_system.get_user_saved_recipes(user_profile)
    recipes = recipes_by_category.get(category, [])
    
    if not recipes:
        # Si no hay recetas para esta categor√≠a, saltar a la siguiente
        next_category = get_next_category(category)
        if next_category:
            meal_bot.user_states[telegram_id]["data"]["current_category"] = next_category
            show_category_recipe_selection(telegram_id, next_category, user_profile)
        else:
            # Todas las categor√≠as procesadas, generar preview
            generate_menu_preview_step(telegram_id, user_profile)
        return
    
    # Crear keyboard con recetas disponibles
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    
    # Botones para cada receta
    for recipe in recipes[:7]:  # M√°ximo 7 recetas por categor√≠a
        # Verificar si ya est√° seleccionada
        is_selected = recipe["id"] in meal_bot.user_states[telegram_id]["data"]["selected_recipes"][category]
        checkbox = "‚úÖ" if is_selected else "‚òê"
        
        # Mostrar nombre y calor√≠as
        display_name = recipe["name"] if len(recipe["name"]) <= 30 else f"{recipe['name'][:27]}..."
        button_text = f"{checkbox} {display_name} ({recipe['calories']} kcal)"
        
        keyboard.add(
            types.InlineKeyboardButton(
                button_text,
                callback_data=f"menu_select_{category}_{recipe['id']}"
            )
        )
    
    # Botones de navegaci√≥n
    keyboard.add(
        types.InlineKeyboardButton("‚û°Ô∏è Continuar con siguiente categor√≠a", callback_data=f"menu_next_{category}")
    )
    
    # Mapear categor√≠as a emojis
    category_icons = {
        "desayuno": "üåÖ",
        "almuerzo": "üçΩÔ∏è", 
        "merienda": "ü•ú",
        "cena": "üåô"
    }
    
    selected_count = len(meal_bot.user_states[telegram_id]["data"]["selected_recipes"][category])
    
    category_text = f"""
{category_icons.get(category, "üçΩÔ∏è")} **SELECCIONAR RECETAS DE {category.upper()}**

**Recetas seleccionadas:** {selected_count}/{len(recipes)}

üìù **Instrucciones:**
‚Ä¢ Selecciona las recetas que quieres incluir en tu men√∫ semanal
‚Ä¢ Puedes elegir de 1 a 7 recetas por categor√≠a
‚Ä¢ **M√°s recetas = m√°s variedad** durante la semana
‚Ä¢ **Menos recetas = se repetir√°n** m√°s d√≠as

‚úÖ = Receta seleccionada
‚òê = Receta disponible

üëÜ **Toca las recetas que quieres incluir:**
"""
    
    bot.send_message(
        telegram_id, 
        category_text, 
        parse_mode='Markdown',
        reply_markup=keyboard
    )

def get_next_category(current_category: str) -> Optional[str]:
    """Obtener la siguiente categor√≠a en el flujo"""
    categories = ["desayuno", "almuerzo", "merienda", "cena"]
    try:
        current_index = categories.index(current_category)
        if current_index < len(categories) - 1:
            return categories[current_index + 1]
    except ValueError:
        pass
    return None

def generate_menu_preview_step(telegram_id: str, user_profile: Dict):
    """Generar preview del men√∫ y mostrar opciones finales"""
    user_state = meal_bot.user_states[telegram_id]
    selected_recipes = user_state["data"]["selected_recipes"]
    
    # Crear distribuci√≥n semanal
    weekly_menu = meal_bot.weekly_menu_system.create_weekly_distribution(selected_recipes, user_profile)
    
    # Generar preview
    preview_text = meal_bot.weekly_menu_system.generate_menu_preview(weekly_menu, user_profile)
    
    # Guardar en estado temporal
    user_state["data"]["weekly_menu"] = weekly_menu
    user_state["step"] = "preview_confirmation"
    
    # Botones de confirmaci√≥n
    keyboard = types.InlineKeyboardMarkup(row_width=2)
    keyboard.add(
        types.InlineKeyboardButton("‚úÖ Confirmar men√∫", callback_data="menu_confirm"),
        types.InlineKeyboardButton("‚úèÔ∏è Editar recetas", callback_data="menu_edit")
    )
    keyboard.add(
        types.InlineKeyboardButton("üíæ Guardar configuraci√≥n", callback_data="menu_save_config")
    )
    
    # Enviar preview
    meal_bot.send_long_message(
        telegram_id, 
        preview_text, 
        parse_mode='Markdown',
        reply_markup=keyboard
    )

@bot.message_handler(commands=['recetas'])
def recetas_command(message):
    """Mostrar recetas generadas por el usuario"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    generated_recipes = user_profile.get("generated_recipes", [])
    
    if not generated_recipes:
        response_text = """
üìö **TUS RECETAS GENERADAS**

‚ùå **No tienes recetas generadas a√∫n**

Para generar recetas personalizadas:
‚Ä¢ Usa /generar para crear recetas espec√≠ficas por timing
‚Ä¢ Usa /buscar [consulta] para recetas con IA

**CATEGOR√çAS DISPONIBLES:**

‚ö° **PRE-ENTRENO** (15-30 min antes)
üí™ **POST-ENTRENO** (0-30 min despu√©s)  
üåÖ **DESAYUNO** - Primera comida del d√≠a
üçΩÔ∏è **ALMUERZO** - Comida principal del mediod√≠a
ü•ú **MERIENDA** - Snack de la tarde
üåô **CENA** - √öltima comida del d√≠a

¬°Genera tu primera receta con /generar!
"""
    else:
        response_text = "üìö **TUS RECETAS GENERADAS**\n\n"
        
        # Agrupar por categor√≠a de timing
        categories = {
            "pre_entreno": "‚ö° **PRE-ENTRENO**",
            "post_entreno": "üí™ **POST-ENTRENO**", 
            "desayuno": "üåÖ **DESAYUNO**",
            "almuerzo": "üçΩÔ∏è **ALMUERZO**",
            "merienda": "ü•ú **MERIENDA**",
            "cena": "üåô **CENA**"
        }
        
        recipes_by_category = {}
        for recipe in generated_recipes[:10]:  # Mostrar solo las 10 m√°s recientes
            category = recipe["timing_category"]
            if category not in recipes_by_category:
                recipes_by_category[category] = []
            recipes_by_category[category].append(recipe)
        
        for category, category_name in categories.items():
            if category in recipes_by_category:
                response_text += f"\n{category_name}\n"
                for i, recipe in enumerate(recipes_by_category[category][:3], 1):  # M√°ximo 3 por categor√≠a
                    recipe_data = recipe["recipe_data"]
                    name = recipe_data.get("nombre", "Receta sin nombre")
                    calories = recipe_data.get("macros_per_portion", {}).get("calories", "N/A")
                    score = recipe["validation_score"]
                    date = recipe["generated_date"][:10]  # Solo fecha
                    
                    response_text += f"‚Ä¢ {name}\n"
                    response_text += f"  {calories} kcal ‚Ä¢ ‚≠ê{score}/100 ‚Ä¢ {date}\n"
                response_text += "\n"
        
        total_recipes = len(generated_recipes)
        response_text += f"**Total de recetas:** {total_recipes}\n"
        response_text += f"**Mostrando:** Las m√°s recientes por categor√≠a\n\n"
        response_text += "üí° **Generar m√°s:** /generar\n"
        response_text += "üîç **B√∫squeda espec√≠fica:** /buscar [consulta]"
    
    meal_bot.send_long_message(message.chat.id, response_text, parse_mode='Markdown')

@bot.message_handler(commands=['complementos'])
def complementos_command(message):
    """Mostrar complementos mediterr√°neos personalizados seg√∫n preferencias"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    preferences = user_profile.get("preferences", {})
    exercise_profile = user_profile.get("exercise_profile", {})
    
    # Obtener preferencias del usuario
    liked_foods = preferences.get("liked_foods", [])
    disliked_foods = preferences.get("disliked_foods", [])
    training_schedule = exercise_profile.get("training_schedule", "variable")
    objetivo = user_profile["basic_data"]["objetivo"]
    
    # Mostrar complementos de la base de datos
    complements = meal_bot.data.get("global_complements", {})
    
    response_text = f"ü•ú **COMPLEMENTOS MEDITERR√ÅNEOS PERSONALIZADOS**\n\n"
    response_text += f"üë§ **Adaptado a tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}\n"
    response_text += f"‚è∞ **Timing:** {exercise_profile.get('training_schedule_desc', 'Variable')}\n\n"
    
    def is_food_preferred(item_name_lower, category_name_lower):
        """Verificar si un complemento coincide con preferencias del usuario"""
        
        # Mapeo de complementos a categor√≠as de alimentos
        food_mappings = {
            # Frutos secos
            "almendras": "frutos_secos", "nueces": "frutos_secos", "pistachos": "frutos_secos",
            "avellanas": "frutos_secos", "anacardos": "frutos_secos",
            
            # L√°cteos
            "yogur": "lacteos", "queso": "lacteos", "feta": "lacteos",
            
            # Aceitunas y derivados
            "aceitunas": "aceitunas", "aceite": "aceitunas",
            
            # Frutas
            "higos": "frutas", "d√°tiles": "frutas", "pasas": "frutas",
            
            # Otros
            "miel": "endulzantes_naturales"
        }
        
        for word, food_category in food_mappings.items():
            if word in item_name_lower:
                return food_category in liked_foods, food_category in disliked_foods
        
        return False, False
    
    total_shown = 0
    preferred_items = []
    neutral_items = []
    avoided_items = []
    
    for category, items in complements.items():
        category_name = category.replace("_", " ").title()
        
        for item_id, item_data in items.items():
            name = item_data["name"]
            portion = item_data["portion_size"]
            unit = item_data["unit"]
            macros = item_data["macros_per_portion"]
            
            # Verificar preferencias
            is_preferred, is_disliked = is_food_preferred(name.lower(), category.lower())
            
            item_text = f"‚Ä¢ {name} ({portion}{unit})\n"
            item_text += f"  {macros['protein']}P / {macros['carbs']}C / {macros['fat']}G = {macros['calories']} kcal"
            
            if is_preferred:
                preferred_items.append((category_name, f"‚úÖ {item_text}"))
            elif is_disliked:
                avoided_items.append((category_name, f"‚ö†Ô∏è {item_text}"))
            else:
                neutral_items.append((category_name, item_text))
    
    # Mostrar complementos preferidos primero
    if preferred_items:
        response_text += "‚≠ê **RECOMENDADOS PARA TI:**\n"
        current_category = ""
        for category_name, item_text in preferred_items:
            if category_name != current_category:
                response_text += f"\n**{category_name.upper()}:**\n"
                current_category = category_name
            response_text += f"{item_text}\n"
        response_text += "\n"
    
    # Mostrar complementos neutrales
    if neutral_items:
        response_text += "üçΩÔ∏è **OTROS COMPLEMENTOS DISPONIBLES:**\n"
        current_category = ""
        for category_name, item_text in neutral_items[:8]:  # Limitar para no sobrecargar
            if category_name != current_category:
                response_text += f"\n**{category_name.upper()}:**\n"
                current_category = category_name
            response_text += f"{item_text}\n"
        response_text += "\n"
    
    # Mostrar complementos a evitar (si los hay)
    if avoided_items:
        response_text += "üö´ **COMPLEMENTOS QUE EVITAS:**\n"
        current_category = ""
        for category_name, item_text in avoided_items:
            if category_name != current_category:
                response_text += f"\n**{category_name.upper()}:**\n"
                current_category = category_name
            response_text += f"{item_text}\n"
        response_text += "\n"
    
    # Timing personalizado seg√∫n horario de entrenamiento
    timing_recommendations = {
        "ma√±ana": {
            "pre": "üåÖ **Pre-entreno (6:00-6:30):** Miel + almendras",
            "post": "‚òÄÔ∏è **Post-entreno (8:00-9:00):** Yogur griego + nueces",
            "tarde": "üåÜ **Tarde:** Aceitunas + queso feta"
        },
        "mediodia": {
            "pre": "‚òÄÔ∏è **Pre-entreno (11:30-12:00):** D√°tiles + pistachos",
            "post": "üåû **Post-entreno (14:00-15:00):** Yogur + miel",
            "tarde": "üåÜ **Tarde:** Frutos secos mixtos"
        },
        "tarde": {
            "pre": "üåÜ **Pre-entreno (15:30-16:00):** Miel + frutos secos",
            "post": "üåô **Post-entreno (20:30-21:00):** Yogur + aceitunas",
            "noche": "üåÉ **Noche:** Complementos seg√∫n macros faltantes"
        },
        "noche": {
            "pre": "üåô **Pre-entreno (19:30-20:00):** Almendras + miel (ligero)",
            "post": "üåÉ **Post-entreno (22:00-22:30):** Yogur (evitar exceso)",
            "descanso": "üò¥ **Antes de dormir:** Solo si faltan macros"
        },
        "variable": {
            "general": "üîÑ **Timing flexible:** Adapta seg√∫n tu horario de entrenamiento",
            "regla": "üìã **Regla general:** Pre-entreno ligero, post-entreno proteico"
        }
    }
    
    schedule_recommendations = timing_recommendations.get(training_schedule, timing_recommendations["variable"])
    
    response_text += "‚è∞ **TIMING PERSONALIZADO PARA TI:**\n"
    for timing_name, recommendation in schedule_recommendations.items():
        response_text += f"{recommendation}\n"
    
    response_text += f"""

üéØ **RECOMENDACIONES PARA {objetivo.upper().replace('_', ' ')}:**
"""
    
    # Recomendaciones espec√≠ficas por objetivo
    objective_recommendations = {
        "bajar_peso": [
            "‚Ä¢ Prioriza complementos altos en prote√≠na (yogur griego)",
            "‚Ä¢ Controla porciones de frutos secos (m√°ximo 30g/d√≠a)",
            "‚Ä¢ Evita miel en exceso (m√°ximo 15g/d√≠a)"
        ],
        "subir_masa": [
            "‚Ä¢ Aumenta frecuencia de frutos secos y aceitunas",
            "‚Ä¢ Combina complementos para maximizar calor√≠as",
            "‚Ä¢ Miel post-entreno para reponer gluc√≥geno"
        ],
        "recomposicion": [
            "‚Ä¢ Timing preciso: prote√≠nas post-entreno",
            "‚Ä¢ Carbohidratos (miel, frutas) solo peri-entreno",
            "‚Ä¢ Grasas saludables en comidas principales"
        ],
        "mantener": [
            "‚Ä¢ Distribuci√≥n equilibrada durante el d√≠a",
            "‚Ä¢ Usa complementos para completar macros faltantes",
            "‚Ä¢ Flexibilidad seg√∫n apetito y actividad"
        ]
    }
    
    recs = objective_recommendations.get(objetivo, objective_recommendations["mantener"])
    for rec in recs:
        response_text += f"{rec}\n"
    
    response_text += f"""

üí° **PERSONALIZACI√ìN ACTIVA:**
‚úÖ Complementos filtrados seg√∫n tus preferencias
‚úÖ Timing adaptado a tu horario de entrenamiento
‚úÖ Recomendaciones espec√≠ficas para tu objetivo
‚úÖ Usa `/editar_perfil` para modificar preferencias
"""
    
    meal_bot.send_long_message(message.chat.id, response_text, parse_mode='Markdown')

@bot.message_handler(commands=['favoritas'])
def favoritas_command(message):
    """Mostrar recetas favoritas del usuario"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    favorite_ids = meal_bot.profile_system.get_user_favorites(user_profile)
    
    if not favorite_ids:
        response_text = """
‚≠ê **TUS RECETAS FAVORITAS**

‚ùå **No tienes recetas favoritas a√∫n**

Para a√±adir recetas a favoritos:
‚Ä¢ Genera recetas con `/generar`
‚Ä¢ Busca recetas con `/buscar [consulta]`
‚Ä¢ Marca las que te gusten con ‚≠ê

**¬°Empieza a generar recetas personalizadas!**
"""
        bot.send_message(message.chat.id, response_text, parse_mode='Markdown')
        return
    
    # Obtener recetas favoritas de la base de datos
    generated_recipes = meal_bot.data.get("generated_recipes", [])
    favorite_recipes = []
    
    for recipe_entry in generated_recipes:
        recipe_id = recipe_entry.get("recipe_id")
        if recipe_id in favorite_ids:
            favorite_recipes.append(recipe_entry)
    
    if not favorite_recipes:
        response_text = """
‚≠ê **TUS RECETAS FAVORITAS**

‚ö†Ô∏è **Recetas favoritas no encontradas**

Puede que algunas recetas favoritas ya no est√©n disponibles.
Genera nuevas recetas con `/generar` y m√°rcalas como favoritas.
"""
        bot.send_message(message.chat.id, response_text, parse_mode='Markdown')
        return
    
    # Mostrar recetas favoritas
    response_text = f"‚≠ê **TUS RECETAS FAVORITAS**\n\n"
    response_text += f"üìö **Total:** {len(favorite_recipes)} recetas\n\n"
    
    # Agrupar por categor√≠a de timing
    categories = {
        "pre_entreno": "‚ö° **PRE-ENTRENO**",
        "post_entreno": "üí™ **POST-ENTRENO**", 
        "comida_principal": "üçΩÔ∏è **COMIDA PRINCIPAL**",
        "snack_complemento": "ü•ú **SNACK/COMPLEMENTO**"
    }
    
    recipes_by_category = {}
    for recipe in favorite_recipes:
        category = recipe.get("timing_category", "comida_principal")
        if category not in recipes_by_category:
            recipes_by_category[category] = []
        recipes_by_category[category].append(recipe)
    
    for category, category_name in categories.items():
        if category in recipes_by_category:
            response_text += f"\n{category_name}\n"
            for i, recipe in enumerate(recipes_by_category[category], 1):
                recipe_data = recipe.get("recipe_data", {})
                name = recipe_data.get("nombre", "Receta sin nombre")
                macros = recipe_data.get("macros_per_portion", recipe_data.get("macros_por_porcion", {}))
                calories = macros.get("calories", macros.get("calorias", "N/A"))
                score = recipe.get("validation_score", 0)
                date = recipe.get("generated_date", "")[:10] if recipe.get("generated_date") else "N/A"
                
                response_text += f"‚≠ê **{name}**\n"
                response_text += f"   {calories} kcal ‚Ä¢ ‚≠ê{score}/100 ‚Ä¢ {date}\n\n"
    
    response_text += """
üí° **GESTI√ìN DE FAVORITAS:**
‚Ä¢ Usa üö´ para quitar de favoritos
‚Ä¢ `/generar` para crear m√°s recetas
‚Ä¢ `/buscar [consulta]` para encontrar espec√≠ficas

**¬°Tus favoritas se guardan autom√°ticamente!**
"""
    
    meal_bot.send_long_message(message.chat.id, response_text, parse_mode='Markdown')

@bot.message_handler(commands=['buscar'])
def buscar_command(message):
    """Comando para buscar/generar recetas con IA"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    # Extraer consulta del mensaje
    query = message.text.replace('/buscar', '').strip()
    
    if not query:
        bot.send_message(
            message.chat.id,
            "üîç **B√öSQUEDA INTELIGENTE DE RECETAS**\n\n"
            "Usa: `/buscar [tu consulta]`\n\n"
            "**Ejemplos:**\n"
            "‚Ä¢ `/buscar pollo post entreno`\n"
            "‚Ä¢ `/buscar legumbres mediterraneas`\n"
            "‚Ä¢ `/buscar snack alto proteina`\n"
            "‚Ä¢ `/buscar desayuno pre entreno`\n\n"
            "La IA generar√° recetas personalizadas seg√∫n tu perfil.",
            parse_mode='Markdown'
        )
        return
    
    # Iniciar b√∫squeda con IA
    meal_bot.user_states[telegram_id] = {
        "state": "ai_search",
        "query": query,
        "step": "processing"
    }
    
    bot.send_message(
        message.chat.id,
        f"ü§ñ **Buscando recetas para:** '{query}'\n\n"
        "‚è≥ Generando opciones personalizadas con IA...\n"
        "üìä Considerando tu perfil nutricional...\n"
        "üçΩÔ∏è Validando ingredientes naturales...",
        parse_mode='Markdown'
    )
    
    # Procesar b√∫squeda (se implementar√° completamente en siguiente fase)
    process_ai_search(telegram_id, query, message)

def determine_optimal_theme(user_profile: Dict) -> str:
    """
    Determinar tema √≥ptimo bas√°ndose en el perfil del usuario
    """
    objetivo = user_profile["basic_data"]["objetivo"]
    available_energy = user_profile["energy_data"]["available_energy"]
    preferences = user_profile.get("preferences", {})
    liked_foods = preferences.get("liked_foods", [])
    
    # Scoring por objetivo
    if objetivo == "subir_masa":
        if available_energy > 50:
            return "alta_proteina"
        else:
            return "energia_sostenida"
    elif objetivo == "bajar_peso":
        if "pescados" in liked_foods or "verduras" in liked_foods:
            return "mediterranea"
        else:
            return "detox_natural"
    elif objetivo == "recomposicion":
        return "variedad_maxima"  # Balance perfecto
    else:  # mantener
        if "frutos_secos" in liked_foods or "aceitunas" in liked_foods:
            return "mediterranea"
        else:
            return "variedad_maxima"

def determine_optimal_cooking_schedule(user_profile: Dict) -> str:
    """
    Determinar cronograma √≥ptimo bas√°ndose en Available Energy
    """
    available_energy = user_profile["energy_data"]["available_energy"]
    
    if available_energy >= 60:
        return "sesion_unica_domingo"  # M√°xima eficiencia
    elif available_energy >= 45:
        return "dos_sesiones"  # Balance
    elif available_energy >= 35:
        return "tres_sesiones"  # Distribuida
    else:
        return "preparacion_diaria"  # M√≠nimo esfuerzo

def generate_intelligent_week(message, user_profile: Dict, theme: str):
    """
    Generar plan semanal inteligente con tema espec√≠fico
    """
    try:
        telegram_id = str(message.from_user.id)
        
        # Mostrar mensaje de generaci√≥n
        processing_msg = bot.send_message(
            message.chat.id,
            "ü§ñ **Generando plan semanal inteligente...**\n\n"
            "‚ö° Analizando tu perfil nutricional\n"
            "üéØ Aplicando algoritmos de variedad\n"
            "üåä Integrando ingredientes estacionales\n"
            "üìä Calculando m√©tricas de calidad\n\n"
            "*Esto puede tomar unos segundos...*",
            parse_mode='Markdown'
        )
        
        # Preparar preferencias de semana
        if theme == "auto":
            # Auto-selecci√≥n inteligente basada en el perfil del usuario
            auto_theme = determine_optimal_theme(user_profile)
            week_preferences = {
                "theme": auto_theme,
                "variety_level": 5,  # M√°ximo nivel de variedad
                "cooking_schedule": determine_optimal_cooking_schedule(user_profile),
                "auto_generated": True
            }
        else:
            week_preferences = {
                "theme": theme,
                "variety_level": 4,  # Alto nivel de variedad
                "cooking_schedule": "dos_sesiones"
            }
        
        # Generar plan semanal
        result = meal_bot.weekly_planner.generate_intelligent_week(
            user_profile, week_preferences
        )
        
        # Eliminar mensaje de procesamiento
        bot.delete_message(message.chat.id, processing_msg.message_id)
        
        if result["success"]:
            # Formatear y enviar resultado
            formatted_plan = meal_bot.weekly_planner.format_weekly_plan_for_telegram(
                result, user_profile
            )
            
            # Crear botones de acci√≥n
            keyboard = types.InlineKeyboardMarkup(row_width=2)
            keyboard.add(
                types.InlineKeyboardButton("üõí Lista de Compras", callback_data="week_shopping_list"),
                types.InlineKeyboardButton("üîÑ Regenerar Semana", callback_data="week_regenerate")
            )
            keyboard.add(
                types.InlineKeyboardButton("‚≠ê Guardar Plan", callback_data="week_save"),
                types.InlineKeyboardButton("üìä Ver M√©tricas", callback_data="week_metrics")
            )
            
            meal_bot.send_long_message(
                message.chat.id, 
                formatted_plan, 
                parse_mode='Markdown',
                reply_markup=keyboard
            )
            
            # Guardar plan en el perfil del usuario
            if "current_week_plan" not in user_profile:
                user_profile["current_week_plan"] = {}
            
            user_profile["current_week_plan"] = {
                "plan_data": result,
                "generated_at": datetime.now().isoformat(),
                "theme_used": theme
            }
            meal_bot.database.save_user_profile(telegram_id, user_profile)
            
        else:
            error_message = f"""
‚ùå **Error generando plan semanal**

**Error:** {result.get('error', 'Error desconocido')}

üîÑ **Soluciones:**
‚Ä¢ Intenta con otro tema semanal
‚Ä¢ Verifica que tu perfil est√© completo
‚Ä¢ Usa `/help` si el problema persiste

**Puedes intentar de nuevo con `/nueva_semana`**
"""
            bot.send_message(message.chat.id, error_message, parse_mode='Markdown')
            
    except Exception as e:
        logger.error(f"Error generating intelligent week: {e}")
        bot.send_message(
            message.chat.id,
            f"‚ùå **Error interno:** {str(e)}\n\nIntenta de nuevo con `/nueva_semana`",
            parse_mode='Markdown'
        )

@bot.message_handler(commands=['nueva_semana'])
def nueva_semana_command(message):
    """Generar plan semanal inteligente"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Extraer argumentos del comando (tema opcional)
    command_parts = message.text.split()
    requested_theme = command_parts[1] if len(command_parts) > 1 else None
    
    # Crear teclado inline para selecci√≥n de tema
    keyboard = types.InlineKeyboardMarkup(row_width=2)
    
    # Botones de temas disponibles
    keyboard.add(
        types.InlineKeyboardButton("üåä Mediterr√°nea", callback_data="theme_mediterranea"),
        types.InlineKeyboardButton("üí™ Alta Prote√≠na", callback_data="theme_alta_proteina")
    )
    keyboard.add(
        types.InlineKeyboardButton("üåø Detox Natural", callback_data="theme_detox_natural"),
        types.InlineKeyboardButton("‚ö° Energ√≠a Sostenida", callback_data="theme_energia_sostenida")
    )
    keyboard.add(
        types.InlineKeyboardButton("üåà Variedad M√°xima", callback_data="theme_variedad_maxima")
    )
    keyboard.add(
        types.InlineKeyboardButton("üéØ Auto-selecci√≥n IA", callback_data="theme_auto")
    )
    
    # Si se especific√≥ tema, generar directamente
    if requested_theme and requested_theme in ['mediterranea', 'alta_proteina', 'detox_natural', 'energia_sostenida', 'variedad_maxima']:
        generate_intelligent_week(message, user_profile, requested_theme)
        return
    
    # Mostrar opciones de tema
    response_text = f"""
üóìÔ∏è **PLANIFICACI√ìN SEMANAL INTELIGENTE**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
üî• **Calor√≠as diarias:** {user_profile['macros']['calories']} kcal
‚ö° **Available Energy:** {user_profile['energy_data']['available_energy']} kcal/kg FFM

üé® **TEMAS SEMANALES DISPONIBLES:**

üåä **Mediterr√°nea** - Ingredientes tradicionales mediterr√°neos
üí™ **Alta Prote√≠na** - Maximizar s√≠ntesis proteica y recuperaci√≥n  
üåø **Detox Natural** - Alimentos depurativos y antioxidantes
‚ö° **Energ√≠a Sostenida** - Carbohidratos complejos y grasas saludables
üåà **Variedad M√°xima** - M√°xima diversidad de ingredientes

üéØ **Auto-selecci√≥n IA** - Deja que la IA elija el tema √≥ptimo para ti

**Selecciona un tema para generar tu plan semanal inteligente:**
"""
    
    bot.send_message(
        message.chat.id,
        response_text,
        reply_markup=keyboard,
        parse_mode='Markdown'
    )

@bot.message_handler(commands=['lista_compras'])
def lista_compras_command(message):
    """Generar lista de compras personalizada autom√°tica"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Mostrar opciones de duraci√≥n
    response_text = f"""
üõí **LISTA DE COMPRAS PERSONALIZADA**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
üî• **Calor√≠as diarias:** {user_profile['macros']['calories']} kcal

üìÖ **¬øPara cu√°ntos d√≠as quieres la lista?**

üÖ∞Ô∏è **3 d√≠as** - Lista compacta para meal prep corto
üÖ±Ô∏è **5 d√≠as** - Lista est√°ndar para semana laboral
üÖ≤Ô∏è **7 d√≠as** - Lista completa para toda la semana
üÖ≥Ô∏è **10 d√≠as** - Lista extendida para compra quincenal

**Responde con la letra de tu opci√≥n (A, B, C, D)**

‚ú® **La lista se adapta autom√°ticamente a:**
‚Ä¢ Tus alimentos preferidos (cantidades aumentadas)
‚Ä¢ Alimentos que evitas (excluidos autom√°ticamente)
‚Ä¢ Tu objetivo nutricional espec√≠fico
‚Ä¢ Complementos mediterr√°neos optimizados
‚Ä¢ Distribuci√≥n inteligente por frescura
"""
    
    meal_bot.user_states[telegram_id] = {
        "state": "shopping_list_setup",
        "step": "choose_days"
    }
    
    meal_bot.send_long_message(message.chat.id, response_text, parse_mode='Markdown')

@bot.message_handler(commands=['generar'])
def generar_command(message):
    """Generar receta espec√≠fica por timing y funci√≥n"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    # Mostrar opciones de generaci√≥n
    keyboard = types.InlineKeyboardMarkup(row_width=2)
    
    # Botones por timing (ocultando pre/post entreno seg√∫n solicitud)
    keyboard.add(
        types.InlineKeyboardButton("üåÖ Desayuno", callback_data="gen_desayuno"),
        types.InlineKeyboardButton("üçΩÔ∏è Almuerzo", callback_data="gen_almuerzo")
    )
    keyboard.add(
        types.InlineKeyboardButton("ü•ú Merienda", callback_data="gen_merienda"),
        types.InlineKeyboardButton("üåô Cena", callback_data="gen_cena")
    )
    
    bot.send_message(
        message.chat.id,
        "ü§ñ **GENERACI√ìN ESPEC√çFICA DE RECETAS**\n\n"
        "Selecciona el tipo de receta que quieres generar seg√∫n tu comida del d√≠a:\n\n"
        "üåÖ **Desayuno:** Primera comida del d√≠a - energ√©tica y nutritiva\n"
        "üçΩÔ∏è **Almuerzo:** Comida principal del mediod√≠a - completa y saciante\n"
        "ü•ú **Merienda:** Snack de la tarde - rico en micronutrientes\n"
        "üåô **Cena:** √öltima comida del d√≠a - ligera y digestiva\n\n"
        "**Cada receta se adaptar√° autom√°ticamente a tu perfil nutricional y enfoque diet√©tico.**",
        parse_mode='Markdown',
        reply_markup=keyboard
    )

@bot.message_handler(commands=['valorar'])
def valorar_command(message):
    """Valorar recetas espec√≠ficas con escala 1-5 estrellas"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Verificar si hay recetas recientes generadas
    recent_recipes = user_profile.get("recent_generated_recipes", [])
    
    if not recent_recipes:
        no_recipes_text = """
‚≠ê **SISTEMA DE VALORACI√ìN 1-5 ESTRELLAS**

‚ùå **No hay recetas para valorar**

Para valorar recetas necesitas:
1. ü§ñ Generar recetas con `/generar`
2. üîç Buscar recetas con `/buscar [consulta]`
3. ‚úÖ Seleccionar recetas de las opciones

üí° **¬øPara qu√© sirven las valoraciones?**
‚Ä¢ Mejorar recomendaciones futuras personalizadas
‚Ä¢ Entrenar la IA con tus preferencias espec√≠ficas
‚Ä¢ Optimizar el algoritmo seg√∫n tu feedback

üéØ **Genera algunas recetas primero y luego regresa aqu√≠**
"""
        
        keyboard = types.InlineKeyboardMarkup()
        keyboard.add(
            types.InlineKeyboardButton("ü§ñ Generar Recetas", callback_data="gen_comida_principal")
        )
        
        bot.send_message(
            message.chat.id,
            no_recipes_text,
            parse_mode='Markdown',
            reply_markup=keyboard
        )
        return
    
    # Mostrar recetas disponibles para valorar
    response_text = """
‚≠ê **VALORAR RECETAS - ESCALA 1-5 ESTRELLAS**

üìã **Selecciona la receta que quieres valorar:**

"""
    
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    
    # Mostrar √∫ltimas 10 recetas
    for i, recipe_data in enumerate(recent_recipes[-10:], 1):
        recipe = recipe_data.get("recipe", {})
        recipe_name = recipe.get("nombre", f"Receta {i}")
        timing = recipe_data.get("timing_category", "")
        
        # Truncar nombre si es muy largo
        display_name = recipe_name if len(recipe_name) <= 35 else f"{recipe_name[:32]}..."
        
        # Agregar emoji seg√∫n timing
        timing_emoji = {
            "desayuno": "üåÖ",
            "almuerzo": "üçΩÔ∏è",
            "merienda": "ü•ú",
            "cena": "üåô",
            "pre_entreno": "‚ö°",
            "post_entreno": "üí™"
        }.get(timing, "üçΩÔ∏è")
        
        keyboard.add(
            types.InlineKeyboardButton(
                f"{timing_emoji} {display_name}",
                callback_data=f"rate_recipe_{i-1}"
            )
        )
    
    response_text += f"üí´ **{len(recent_recipes[-10:])} recetas disponibles**\n\n"
    response_text += "üåü **Escala de valoraci√≥n:**\n"
    response_text += "‚≠ê = No me gust√≥\n"
    response_text += "‚≠ê‚≠ê = Regular\n" 
    response_text += "‚≠ê‚≠ê‚≠ê = Buena\n"
    response_text += "‚≠ê‚≠ê‚≠ê‚≠ê = Muy buena\n"
    response_text += "‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê = Excelente\n\n"
    response_text += "ü§ñ **Tus valoraciones ayudan a la IA a generar mejores recomendaciones**"
    
    bot.send_message(
        message.chat.id,
        response_text,
        parse_mode='Markdown',
        reply_markup=keyboard
    )

@bot.message_handler(commands=['valorar_receta'])
def valorar_receta_command(message):
    """Valorar receta para mejorar IA"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Verificar si hay recetas recientes generadas
    recent_recipes = user_profile.get("recent_generated_recipes", [])
    
    if not recent_recipes:
        no_recipes_text = """
‚≠ê **VALORAR RECETAS - SISTEMA DE APRENDIZAJE IA**

‚ùå **No hay recetas recientes para valorar**

Para poder valorar recetas necesitas:
1. ü§ñ Generar recetas con `/generar`
2. üîç Buscar recetas con `/buscar [consulta]`
3. üìÖ Crear plan semanal con `/nueva_semana`

üí° **¬øPor qu√© valorar recetas?**
‚Ä¢ La IA aprende tus preferencias autom√°ticamente
‚Ä¢ Mejoran las recomendaciones personalizadas
‚Ä¢ El sistema se adapta a tu gusto espec√≠fico
‚Ä¢ Planes semanales m√°s precisos

üöÄ **Genera tu primera receta:**
"""
        
        # Crear botones para generar receta
        keyboard = types.InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            types.InlineKeyboardButton("ü§ñ Generar Receta", callback_data="gen_comida_principal"),
            types.InlineKeyboardButton("üìÖ Plan Semanal", callback_data="theme_auto")
        )
        
        bot.send_message(
            message.chat.id,
            no_recipes_text,
            parse_mode='Markdown',
            reply_markup=keyboard
        )
        return
    
    # Mostrar recetas disponibles para valorar
    keyboard = types.InlineKeyboardMarkup(row_width=1)
    
    response_text = f"""
‚≠ê **VALORAR RECETAS - APRENDER PREFERENCIAS**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
üß† **IA Score:** {meal_bot.recipe_intelligence._calculate_intelligence_score(user_profile.get('recipe_intelligence', {}))} /100

üìã **RECETAS DISPONIBLES PARA VALORAR:**

"""
    
    # Mostrar hasta 5 recetas m√°s recientes
    for i, recipe in enumerate(recent_recipes[-5:]):
        recipe_name = recipe.get("nombre", f"Receta {i+1}")
        recipe_timing = recipe.get("categoria_timing", "general")
        calories = recipe.get("macros_por_porcion", {}).get("calorias", 0)
        
        response_text += f"**{i+1}.** {recipe_name}\n"
        response_text += f"   üéØ {recipe_timing.replace('_', ' ').title()} ‚Ä¢ {calories} kcal\n\n"
        
        # Bot√≥n para valorar esta receta espec√≠fica
        keyboard.add(
            types.InlineKeyboardButton(
                f"‚≠ê Valorar: {recipe_name[:25]}{'...' if len(recipe_name) > 25 else ''}",
                callback_data=f"rate_recipe_{i}"
            )
        )
    
    # Bot√≥n para ver reporte de inteligencia
    keyboard.add(
        types.InlineKeyboardButton("üß† Ver Reporte de IA", callback_data="show_intelligence_report")
    )
    
    response_text += """
üí° **ESCALA DE VALORACI√ìN:**
‚≠ê = Muy malo (la IA evitar√° ingredientes/estilos similares)
‚≠ê‚≠ê = Malo (reduce recomendaciones similares)  
‚≠ê‚≠ê‚≠ê = Neutro (sin cambios en preferencias)
‚≠ê‚≠ê‚≠ê‚≠ê = Bueno (aumenta recomendaciones similares)
‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê = Excelente (prioriza ingredientes/estilos similares)

**¬°Cada valoraci√≥n mejora autom√°ticamente tus recomendaciones futuras!**
"""
    
    meal_bot.send_long_message(
        message.chat.id,
        response_text,
        parse_mode='Markdown',
        reply_markup=keyboard
    )

@bot.message_handler(commands=['insights_ia'])
def insights_ia_command(message):
    """Ver an√°lisis detallado de preferencias aprendidas por la IA"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Obtener insights detallados de preferencias
    insights = meal_bot.recipe_intelligence.get_user_preference_insights(user_profile)
    
    if not insights.get("insights_available"):
        not_available_text = """
üß† **AN√ÅLISIS DE PREFERENCIAS IA**

‚ùå **Sin datos suficientes para an√°lisis**

Para activar el an√°lisis avanzado necesitas:
‚Ä¢ ü§ñ Generar recetas con `/generar`
‚Ä¢ ‚≠ê Valorar recetas con `/valorar_receta`
‚Ä¢ üîÑ Seleccionar opciones del sistema m√∫ltiple

üí° **¬øQu√© incluye el an√°lisis IA?**
‚Ä¢ Patrones de ingredientes preferidos/evitados
‚Ä¢ M√©todos de cocci√≥n que m√°s te gustan
‚Ä¢ An√°lisis nutricional personalizado
‚Ä¢ Preferencias de timing (desayuno, almuerzo, etc.)
‚Ä¢ Tendencias diet√©ticas identificadas
‚Ä¢ Fuerza de las recomendaciones

üöÄ **Comienza generando tu primera receta:**
"""
        
        keyboard = types.InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            types.InlineKeyboardButton("ü§ñ Generar Receta", callback_data="gen_comida_principal"),
            types.InlineKeyboardButton("‚≠ê Valorar Existentes", url="t.me/" + bot.get_me().username + "?start=valorar")
        )
        
        bot.send_message(
            message.chat.id,
            not_available_text,
            parse_mode='Markdown',
            reply_markup=keyboard
        )
        return
    
    # Formatear insights detallados
    insights_text = f"""
üß† **AN√ÅLISIS AVANZADO DE PREFERENCIAS IA**

üë§ **Usuario:** {user_profile['basic_data']['objetivo_descripcion']}
üìä **Datos analizados:** {insights['total_data_points']} selecciones/valoraciones
üéØ **Confianza del sistema:** {insights['confidence_level']:.1f}/100
üí™ **Fuerza recomendaciones:** {insights['recommendation_strength'].replace('_', ' ').title()}

"""
    
    # An√°lisis de ingredientes
    ingredient_insights = insights['ingredient_insights']
    if ingredient_insights.get('strong_preferences', 0) > 0:
        insights_text += "ü•ó **AN√ÅLISIS DE INGREDIENTES:**\n"
        insights_text += f"‚Ä¢ Preferencias fuertes: {ingredient_insights['strong_preferences']}\n"
        insights_text += f"‚Ä¢ Rechazos identificados: {ingredient_insights['strong_dislikes']}\n"
        
        if ingredient_insights.get('preferred_proteins'):
            insights_text += f"‚Ä¢ Prote√≠nas favoritas: {', '.join(ingredient_insights['preferred_proteins'])}\n"
        
        if ingredient_insights.get('preferred_plants'):
            insights_text += f"‚Ä¢ Vegetales preferidos: {', '.join(ingredient_insights['preferred_plants'])}\n"
        
        insights_text += f"‚Ä¢ Patr√≥n diet√©tico: {ingredient_insights['dietary_pattern'].replace('_', ' ').title()}\n\n"
    
    # An√°lisis de m√©todos de cocci√≥n
    method_insights = insights['method_insights']
    if method_insights.get('preferred_methods'):
        insights_text += "üë®‚Äçüç≥ **M√âTODOS DE COCCI√ìN:**\n"
        insights_text += f"‚Ä¢ M√©todos preferidos: {', '.join(method_insights['preferred_methods'])}\n"
        insights_text += f"‚Ä¢ Complejidad: {method_insights['complexity_preference'].title()}\n"
        insights_text += f"‚Ä¢ Versatilidad: {method_insights['versatility_score']:.1%}\n\n"
    
    # An√°lisis nutricional
    nutrition_insights = insights['nutrition_insights']
    if nutrition_insights.get('preferred_macro_pattern'):
        insights_text += "üéØ **PATRONES NUTRICIONALES:**\n"
        insights_text += f"‚Ä¢ Patr√≥n de macros: {nutrition_insights['preferred_macro_pattern'].replace('_', ' ').title()}\n"
        insights_text += f"‚Ä¢ Enfoque nutricional: {nutrition_insights['nutrition_focus'].replace('_', ' ').title()}\n"
        insights_text += f"‚Ä¢ Flexibilidad: {nutrition_insights['flexibility']:.1%}\n\n"
    
    # An√°lisis de timing
    timing_insights = insights['timing_insights']
    if timing_insights.get('preferred_timing'):
        insights_text += "‚è∞ **PREFERENCIAS DE TIMING:**\n"
        insights_text += f"‚Ä¢ Timing preferido: {timing_insights['preferred_timing'].replace('_', ' ').title()}\n"
        insights_text += f"‚Ä¢ Flexibilidad horaria: {timing_insights['timing_flexibility']}/4\n"
        insights_text += f"‚Ä¢ Enfoque en entreno: {'S√≠' if timing_insights['training_focus'] else 'No'}\n\n"
    
    # Recomendaciones para mejorar
    insights_text += "üí° **RECOMENDACIONES PARA MEJORAR IA:**\n"
    
    if insights['total_data_points'] < 10:
        insights_text += "‚Ä¢ Genera y valora m√°s recetas (objetivo: 10+ valoraciones)\n"
    
    if insights['confidence_level'] < 50:
        insights_text += "‚Ä¢ Usa toda la escala de valoraci√≥n (1-5 estrellas)\n"
        insights_text += "‚Ä¢ Selecciona opciones variadas en el sistema m√∫ltiple\n"
    
    if insights['recommendation_strength'] == 'weak':
        insights_text += "‚Ä¢ Interact√∫a m√°s frecuentemente con las recomendaciones\n"
    
    insights_text += f"""

ü§ñ **COMANDOS IA AVANZADOS:**
‚Ä¢ `/valorar_receta` - Valorar para aprender
‚Ä¢ `/generar` - Recetas personalizadas
‚Ä¢ üß† Ver Reporte IA (en valorar recetas)

**¬°La IA mejora autom√°ticamente con cada interacci√≥n!**
"""
    
    meal_bot.send_long_message(
        message.chat.id,
        insights_text,
        parse_mode='Markdown'
    )

@bot.message_handler(commands=['progreso'])
def progreso_command(message):
    """Seguimiento de progreso y m√©tricas del usuario"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Verificar si tiene datos de tracking
    tracking_data = user_profile.get("progress_tracking", {})
    has_data = tracking_data and tracking_data.get("metrics")
    
    if has_data:
        # Mostrar opciones de progreso
        keyboard = types.InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            types.InlineKeyboardButton("üìä Ver Reporte", callback_data="progress_report"),
            types.InlineKeyboardButton("üìà Registrar M√©trica", callback_data="progress_record")
        )
        keyboard.add(
            types.InlineKeyboardButton("üìÖ Reporte Semanal", callback_data="progress_week"),
            types.InlineKeyboardButton("üìÜ Reporte Mensual", callback_data="progress_month")
        )
        keyboard.add(
            types.InlineKeyboardButton("üéØ Configurar Objetivos", callback_data="progress_goals")
        )
        
        # Obtener m√©tricas b√°sicas
        total_metrics = len(tracking_data.get("metrics", {}))
        total_records = sum(len(records) for records in tracking_data.get("metrics", {}).values())
        
        # √öltima m√©trica registrada
        last_record_date = "Nunca"
        for metric_records in tracking_data.get("metrics", {}).values():
            if metric_records:
                last_date = datetime.fromisoformat(metric_records[-1]["timestamp"])
                if last_record_date == "Nunca" or last_date > datetime.fromisoformat(last_record_date):
                    last_record_date = last_date.strftime("%d/%m/%Y")
        
        progress_text = f"""
üìä **SEGUIMIENTO DE PROGRESO**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
üéØ **Objetivo:** {user_profile['basic_data']['objetivo'].replace('_', ' ').title()}

üìà **ESTAD√çSTICAS DE TRACKING:**
‚Ä¢ M√©tricas registradas: {total_metrics} tipos
‚Ä¢ Total de registros: {total_records}
‚Ä¢ √öltimo registro: {last_record_date}

**¬øQu√© quieres hacer?**
"""
        
        bot.send_message(
            message.chat.id,
            progress_text,
            parse_mode='Markdown',
            reply_markup=keyboard
        )
    
    else:
        # Primera vez - introducir el sistema
        keyboard = types.InlineKeyboardMarkup(row_width=1)
        keyboard.add(
            types.InlineKeyboardButton("üìà Registrar Primera M√©trica", callback_data="progress_record"),
            types.InlineKeyboardButton("‚ùì ¬øC√≥mo Funciona?", callback_data="progress_help")
        )
        
        intro_text = f"""
üìä **SISTEMA DE SEGUIMIENTO DE PROGRESO**

üë§ **Tu objetivo:** {user_profile['basic_data']['objetivo_descripcion']}

üéØ **¬øQU√â PUEDES TRACKEAR?**
‚öñÔ∏è Peso corporal
üìä Porcentaje de grasa
üí™ Masa muscular  
üìè Circunferencia de cintura
‚ö° Nivel de energ√≠a
üí§ Calidad de sue√±o
üîÑ Recuperaci√≥n post-entreno
üçΩÔ∏è Control del apetito

üí° **BENEFICIOS DEL TRACKING:**
‚Ä¢ An√°lisis autom√°tico de tendencias
‚Ä¢ Insights personalizados con IA
‚Ä¢ Recomendaciones adaptativas
‚Ä¢ Detecci√≥n de patrones
‚Ä¢ Ajustes autom√°ticos del plan

üöÄ **COMIENZA AHORA:**
**Registra tu primera m√©trica para activar el sistema inteligente de seguimiento.**
"""
        
        bot.send_message(
            message.chat.id,
            intro_text,
            parse_mode='Markdown',
            reply_markup=keyboard
        )

@bot.message_handler(commands=['planificar_semana'])
def planificar_semana_command(message):
    """Generar cronograma optimizado de meal prep personalizado"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Extraer par√°metros del comando (opcional)
    args = message.text.split()[1:] if len(message.text.split()) > 1 else []
    
    # Configurar preferencias por defecto
    default_preferences = {
        "max_prep_time_hours": 6,
        "preferred_prep_days": ["domingo"],
        "max_session_hours": 4,
        "cooking_experience": "intermedio",
        "freshness_priority": 7,
        "time_efficiency_priority": 8,
        "storage_capacity": "medio",
        "kitchen_equipment": ["basico"]
    }
    
    # Si hay argumentos, permitir personalizaci√≥n r√°pida
    if args:
        if "rapido" in args:
            default_preferences["time_efficiency_priority"] = 10
            default_preferences["max_prep_time_hours"] = 4
        elif "fresco" in args:
            default_preferences["freshness_priority"] = 10
            default_preferences["preferred_prep_days"] = ["domingo", "miercoles"]
        elif "simple" in args:
            default_preferences["cooking_experience"] = "principiante"
            default_preferences["max_session_hours"] = 2
    
    # Mostrar mensaje de procesamiento
    processing_msg = bot.send_message(
        message.chat.id,
        "üóìÔ∏è **GENERANDO CRONOGRAMA OPTIMIZADO...**\n\n"
        "‚öôÔ∏è Analizando tu perfil y restricciones\n"
        "üìä Calculando carga de trabajo total\n"
        "üéØ Optimizando distribuci√≥n temporal\n"
        "üìà Aplicando algoritmos de eficiencia\n\n"
        "*Esto puede tomar unos segundos...*",
        parse_mode='Markdown'
    )
    
    try:
        # Generar cronograma optimizado
        result = meal_bot.meal_prep_scheduler.generate_optimized_schedule(
            user_profile, default_preferences
        )
        
        # Eliminar mensaje de procesamiento
        bot.delete_message(message.chat.id, processing_msg.message_id)
        
        if result["success"]:
            # Formatear y enviar cronograma
            formatted_schedule = meal_bot.meal_prep_scheduler.format_schedule_for_telegram(
                result, user_profile
            )
            
            meal_bot.send_long_message(
                message.chat.id,
                formatted_schedule,
                parse_mode='Markdown'
            )
            
            # Botones de acciones r√°pidas
            keyboard = types.InlineKeyboardMarkup(row_width=2)
            keyboard.add(
                types.InlineKeyboardButton("üìã Lista de Compras", callback_data="generate_shopping_list"),
                types.InlineKeyboardButton("üóìÔ∏è Nuevo Cronograma", callback_data="new_schedule")
            )
            keyboard.add(
                types.InlineKeyboardButton("‚öôÔ∏è Personalizar", callback_data="customize_schedule"),
                types.InlineKeyboardButton("üìä Ver Eficiencia", callback_data="schedule_metrics")
            )
            
            bot.send_message(
                message.chat.id,
                "üéØ **¬øQu√© quieres hacer con tu cronograma?**",
                parse_mode='Markdown',
                reply_markup=keyboard
            )
            
        else:
            error_msg = result.get("error", "Error desconocido")
            bot.send_message(
                message.chat.id,
                f"‚ùå **Error generando cronograma:**\n{error_msg}\n\n"
                "üí° **Intenta:**\n"
                "‚Ä¢ Usar `/planificar_semana` de nuevo\n"
                "‚Ä¢ Verificar que tu perfil est√© completo con `/mis_macros`\n"
                "‚Ä¢ Usar argumentos: `/planificar_semana rapido` o `/planificar_semana fresco`",
                parse_mode='Markdown'
            )
    
    except Exception as e:
        # Eliminar mensaje de procesamiento si existe
        try:
            bot.delete_message(message.chat.id, processing_msg.message_id)
        except:
            pass
        
        logger.error(f"Error in planificar_semana_command: {e}")
        bot.send_message(
            message.chat.id,
            f"‚ùå **Error procesando cronograma:**\n{str(e)}\n\n"
            "üí° **Soluciones:**\n"
            "‚Ä¢ Intenta de nuevo en unos momentos\n"
            "‚Ä¢ Verifica que tu perfil est√© completo\n"
            "‚Ä¢ Usa `/perfil` si es tu primera vez\n"
            "‚Ä¢ Contacta soporte si persiste el error",
            parse_mode='Markdown'
        )

@bot.message_handler(commands=['analisis_nutricional'])
def analisis_nutricional_command(message):
    """Generar an√°lisis nutricional profundo con IA avanzada"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    # Extraer per√≠odo del comando (opcional)
    args = message.text.split()[1:]
    period = "month"  # Default
    
    if args:
        if "semana" in args[0].lower() or "week" in args[0].lower():
            period = "week"
        elif "trimestre" in args[0].lower() or "quarter" in args[0].lower():
            period = "quarter"
        elif "mes" in args[0].lower() or "month" in args[0].lower():
            period = "month"
    
    # Verificar datos suficientes
    progress_data = user_profile.get("progress_tracking", {})
    recipe_intelligence = user_profile.get("recipe_intelligence", {})
    
    has_progress_data = progress_data and progress_data.get("metrics")
    has_recipe_data = recipe_intelligence and recipe_intelligence.get("ratings_history")
    
    if not has_progress_data and not has_recipe_data:
        # Usuario sin datos - mostrar introducci√≥n
        intro_text = f"""
üß¨ **AN√ÅLISIS NUTRICIONAL PROFUNDO CON IA**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}

‚ùå **DATOS INSUFICIENTES PARA AN√ÅLISIS COMPLETO**

üéØ **PARA DESBLOQUEAR AN√ÅLISIS PROFUNDO NECESITAS:**

üìä **DATOS DE PROGRESO:**
‚Ä¢ Registra m√©tricas con `/progreso`
‚Ä¢ M√≠nimo: peso, energ√≠a, sue√±o (1 semana)
‚Ä¢ Recomendado: 4+ m√©tricas (2+ semanas)

‚≠ê **DATOS DE PREFERENCIAS:**
‚Ä¢ Valora recetas con `/valorar_receta`
‚Ä¢ M√≠nimo: 3 valoraciones
‚Ä¢ Recomendado: 10+ valoraciones variadas

üî¨ **EL AN√ÅLISIS INCLUIR√Å:**
‚Ä¢ **Distribuci√≥n de macronutrientes** - Adherencia vs objetivo
‚Ä¢ **Estado de micronutrientes** - Deficiencias y fortalezas
‚Ä¢ **Patrones de adherencia** - Consistencia y factores
‚Ä¢ **Timing nutricional** - Optimizaci√≥n per objetivos
‚Ä¢ **Variedad alimentaria** - Diversidad y monoton√≠a
‚Ä¢ **Correlaciones con progreso** - Qu√© funciona para ti
‚Ä¢ **Puntuaci√≥n nutricional global** - Score 0-100
‚Ä¢ **Recomendaciones personalizadas** - IA adaptada

üöÄ **PASOS PARA ACTIVAR:**
1. Usa `/progreso` para registrar primera m√©trica
2. Usa `/valorar_receta` para entrenar IA
3. Regresa en 3-7 d√≠as para an√°lisis completo

üí° **AN√ÅLISIS DISPONIBLES:**
‚Ä¢ `/analisis_nutricional semana` - An√°lisis semanal
‚Ä¢ `/analisis_nutricional mes` - An√°lisis mensual (recomendado)
‚Ä¢ `/analisis_nutricional trimestre` - An√°lisis de tendencias

**¬°El an√°lisis m√°s avanzado se desbloquea con m√°s datos!**
"""
        
        keyboard = types.InlineKeyboardMarkup(row_width=2)
        keyboard.add(
            types.InlineKeyboardButton("üìä Registrar M√©trica", callback_data="progress_record"),
            types.InlineKeyboardButton("‚≠ê Valorar Recetas", callback_data="start_rating")
        )
        keyboard.add(
            types.InlineKeyboardButton("‚ùì ¬øC√≥mo Funciona?", callback_data="analytics_help")
        )
        
        meal_bot.send_long_message(
            message.chat.id,
            intro_text,
            parse_mode='Markdown',
            reply_markup=keyboard
        )
        return
    
    # Usuario con datos - generar an√°lisis
    period_names = {"week": "semanal", "month": "mensual", "quarter": "trimestral"}
    period_display = period_names.get(period, "mensual")
    
    # Mostrar mensaje de procesamiento
    processing_msg = bot.send_message(
        message.chat.id,
        f"üß¨ **GENERANDO AN√ÅLISIS NUTRICIONAL {period_display.upper()}...**\n\n"
        "üî¨ Analizando distribuci√≥n de macronutrientes\n"
        "‚öóÔ∏è Evaluando estado de micronutrientes\n"
        "üìä Calculando adherencia al plan\n"
        "‚è∞ Optimizando timing nutricional\n"
        "üåà Analizando variedad alimentaria\n"
        "üîó Detectando correlaciones con progreso\n"
        "üéØ Generando puntuaci√≥n global\n"
        "üí° Creando recomendaciones con IA\n\n"
        "*An√°lisis profundo en proceso...*",
        parse_mode='Markdown'
    )
    
    try:
        # Generar an√°lisis completo
        result = meal_bot.nutrition_analytics.generate_comprehensive_analysis(
            user_profile, period
        )
        
        # Eliminar mensaje de procesamiento
        bot.delete_message(message.chat.id, processing_msg.message_id)
        
        if result["success"]:
            # Formatear y enviar an√°lisis
            formatted_analysis = meal_bot.nutrition_analytics.format_analysis_for_telegram(
                result, user_profile
            )
            
            meal_bot.send_long_message(
                message.chat.id,
                formatted_analysis,
                parse_mode='Markdown'
            )
            
            # Botones de acciones basadas en an√°lisis
            keyboard = types.InlineKeyboardMarkup(row_width=2)
            
            # Acciones basadas en puntuaci√≥n
            overall_score = result["nutrition_score"]["overall_score"]
            
            if overall_score < 70:
                keyboard.add(
                    types.InlineKeyboardButton("üéØ Plan de Mejora", callback_data="create_improvement_plan"),
                    types.InlineKeyboardButton("üìã Lista Optimizada", callback_data="generate_shopping_list")
                )
            else:
                keyboard.add(
                    types.InlineKeyboardButton("üî¨ An√°lisis Avanzado", callback_data="advanced_analytics"),
                    types.InlineKeyboardButton("üìä Exportar Datos", callback_data="export_analytics")
                )
            
            keyboard.add(
                types.InlineKeyboardButton("üÜï Nuevo An√°lisis", callback_data="new_nutrition_analysis"),
                types.InlineKeyboardButton("üìà Ver Progreso", callback_data="progress_report")
            )
            
            bot.send_message(
                message.chat.id,
                f"üéØ **An√°lisis completado - Score: {overall_score:.1f}/100**\n\n"
                "**¬øQu√© quieres hacer con estos insights?**",
                parse_mode='Markdown',
                reply_markup=keyboard
            )
            
        else:
            error_msg = result.get("error", "Error desconocido")
            suggestions = result.get("suggestions", [])
            
            error_text = f"‚ùå **Error en an√°lisis nutricional:**\n{error_msg}\n\n"
            
            if suggestions:
                error_text += "üí° **Sugerencias:**\n"
                for suggestion in suggestions:
                    error_text += f"‚Ä¢ {suggestion}\n"
                error_text += "\n"
            
            error_text += "üîÑ **Intenta:**\n"
            error_text += "‚Ä¢ Registrar m√°s m√©tricas con `/progreso`\n"
            error_text += "‚Ä¢ Valorar m√°s recetas con `/valorar_receta`\n"
            error_text += "‚Ä¢ Usar per√≠odo m√°s corto: `/analisis_nutricional semana`\n"
            error_text += "‚Ä¢ Esperar unos d√≠as y repetir el an√°lisis"
            
            bot.send_message(
                message.chat.id,
                error_text,
                parse_mode='Markdown'
            )
    
    except Exception as e:
        # Eliminar mensaje de procesamiento si existe
        try:
            bot.delete_message(message.chat.id, processing_msg.message_id)
        except:
            pass
        
        logger.error(f"Error in analisis_nutricional_command: {e}")
        bot.send_message(
            message.chat.id,
            f"‚ùå **Error procesando an√°lisis nutricional:**\n{str(e)}\n\n"
            "üí° **Soluciones:**\n"
            "‚Ä¢ Verifica que tengas datos de progreso registrados\n"
            "‚Ä¢ Intenta an√°lisis semanal: `/analisis_nutricional semana`\n"
            "‚Ä¢ Contacta soporte si el error persiste\n"
            "‚Ä¢ Usa `/progreso` para registrar m√°s datos",
            parse_mode='Markdown'
        )

@bot.callback_query_handler(func=lambda call: call.data.startswith('theme_'))
def handle_theme_selection_callback(call):
    """Manejar callbacks de selecci√≥n de tema semanal"""
    telegram_id = str(call.from_user.id)
    
    try:
        # Extraer tema seleccionado
        theme_key = call.data.replace('theme_', '')
        
        user_profile = meal_bot.get_user_profile(telegram_id)
        if not user_profile:
            bot.answer_callback_query(call.id, "‚ùå Error: Perfil no encontrado")
            return
        
        # Confirmar selecci√≥n
        theme_names = {
            "mediterranea": "üåä Mediterr√°nea",
            "alta_proteina": "üí™ Alta Prote√≠na", 
            "detox_natural": "üåø Detox Natural",
            "energia_sostenida": "‚ö° Energ√≠a Sostenida",
            "variedad_maxima": "üåà Variedad M√°xima",
            "auto": "üéØ Auto-selecci√≥n IA"
        }
        
        selected_theme_name = theme_names.get(theme_key, "Tema desconocido")
        
        bot.answer_callback_query(
            call.id, 
            f"‚úÖ Generando plan {selected_theme_name}..."
        )
        
        # Crear mensaje simulado para la funci√≥n helper
        class MockMessage:
            def __init__(self, chat_id):
                self.chat = type('obj', (object,), {'id': chat_id})
        
        mock_message = MockMessage(call.message.chat.id)
        
        # Generar plan semanal inteligente
        generate_intelligent_week(mock_message, user_profile, theme_key)
        
    except Exception as e:
        logger.error(f"Error in theme selection callback: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando selecci√≥n")

@bot.callback_query_handler(func=lambda call: call.data.startswith('week_'))
def handle_week_actions_callback(call):
    """Manejar callbacks de acciones del plan semanal"""
    telegram_id = str(call.from_user.id)
    
    try:
        action = call.data.replace('week_', '')
        user_profile = meal_bot.get_user_profile(telegram_id)
        
        if not user_profile:
            bot.answer_callback_query(call.id, "‚ùå Error: Perfil no encontrado")
            return
        
        current_plan = user_profile.get("current_week_plan")
        if not current_plan:
            bot.answer_callback_query(call.id, "‚ùå No hay plan activo")
            return
        
        if action == "shopping_list":
            # Generar lista de compras para el plan actual
            shopping_result = meal_bot.shopping_generator.generate_shopping_list(
                user_profile, days=5
            )
            
            if shopping_result["success"]:
                formatted_list = meal_bot.shopping_generator.format_shopping_list_for_telegram(
                    shopping_result, user_profile
                )
                meal_bot.send_long_message(
                    call.message.chat.id,
                    formatted_list,
                    parse_mode='Markdown'
                )
                bot.answer_callback_query(call.id, "‚úÖ Lista generada")
            else:
                bot.answer_callback_query(call.id, "‚ùå Error generando lista")
        
        elif action == "regenerate":
            # Regenerar plan con el mismo tema
            theme_used = current_plan.get("theme_used", "auto")
            
            class MockMessage:
                def __init__(self, chat_id):
                    self.chat = type('obj', (object,), {'id': chat_id})
            
            mock_message = MockMessage(call.message.chat.id)
            generate_intelligent_week(mock_message, user_profile, theme_used)
            bot.answer_callback_query(call.id, "üîÑ Regenerando plan...")
        
        elif action == "save":
            # Guardar plan en favoritos
            if "saved_weekly_plans" not in user_profile:
                user_profile["saved_weekly_plans"] = []
            
            # Agregar timestamp al plan guardado
            saved_plan = current_plan.copy()
            saved_plan["saved_at"] = datetime.now().isoformat() 
            saved_plan["plan_name"] = f"Plan {saved_plan['theme_used'].title()} - {datetime.now().strftime('%d/%m')}"
            
            user_profile["saved_weekly_plans"].append(saved_plan)
            
            # Mantener solo los √∫ltimos 10 planes guardados
            if len(user_profile["saved_weekly_plans"]) > 10:
                user_profile["saved_weekly_plans"] = user_profile["saved_weekly_plans"][-10:]
            
            meal_bot.database.save_user_profile(telegram_id, user_profile)
            bot.answer_callback_query(call.id, "‚≠ê Plan guardado en favoritos")
        
        elif action == "metrics":
            # Mostrar m√©tricas detalladas del plan
            plan_data = current_plan["plan_data"]
            quality_metrics = plan_data["quality_metrics"]
            
            metrics_text = f"""
üìä **M√âTRICAS DETALLADAS DEL PLAN**

üéØ **Puntuaci√≥n General:** {quality_metrics['overall_score']}/100

üìà **An√°lisis de Variedad:**
‚Ä¢ Puntuaci√≥n variedad: {quality_metrics['variety_score']}/5.0
‚Ä¢ Diversidad ingredientes: {quality_metrics['ingredient_diversity']} tipos √∫nicos
‚Ä¢ M√©todos de cocci√≥n: {quality_metrics['method_diversity']} diferentes

üåä **Integraci√≥n Tem√°tica:**
‚Ä¢ Tema aplicado: {quality_metrics['theme_consistency']}
‚Ä¢ Comidas estacionales: {quality_metrics['seasonal_integration']}

‚≠ê **Evaluaci√≥n:**
"""
            
            # A√±adir evaluaci√≥n cualitativa
            if quality_metrics['overall_score'] >= 80:
                metrics_text += "‚úÖ **Excelente** - Plan √≥ptimo con alta variedad\n"
            elif quality_metrics['overall_score'] >= 60:
                metrics_text += "üü° **Bueno** - Plan s√≥lido con variedad aceptable\n"  
            else:
                metrics_text += "üîÑ **Mejorable** - Considera regenerar el plan\n"
            
            metrics_text += f"\nüí° **Generado:** {datetime.fromisoformat(current_plan['generated_at']).strftime('%d/%m/%Y %H:%M')}"
            
            bot.send_message(
                call.message.chat.id,
                metrics_text,
                parse_mode='Markdown'
            )
            bot.answer_callback_query(call.id, "üìä M√©tricas mostradas")
        
    except Exception as e:
        logger.error(f"Error in week actions callback: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando acci√≥n")

@bot.callback_query_handler(func=lambda call: call.data.startswith('rate_recipe_'))
def handle_rate_recipe_callback(call):
    """Manejar callbacks de selecci√≥n de receta para valorar"""
    telegram_id = str(call.from_user.id)
    
    try:
        # Extraer √≠ndice de receta
        recipe_index = int(call.data.replace('rate_recipe_', ''))
        
        user_profile = meal_bot.get_user_profile(telegram_id)
        if not user_profile:
            bot.answer_callback_query(call.id, "‚ùå Error: Perfil no encontrado")
            return
        
        recent_recipes = user_profile.get("recent_generated_recipes", [])
        if recipe_index >= len(recent_recipes):
            bot.answer_callback_query(call.id, "‚ùå Receta no encontrada")
            return
        
        selected_recipe = recent_recipes[-(recipe_index + 1)]  # Orden inverso
        
        # Crear teclado de valoraci√≥n
        keyboard = types.InlineKeyboardMarkup(row_width=5)
        
        # Botones de estrellas
        star_buttons = []
        for rating in range(1, 6):
            stars = "‚≠ê" * rating
            star_buttons.append(
                types.InlineKeyboardButton(stars, callback_data=f"rating_{recipe_index}_{rating}")
            )
        keyboard.add(*star_buttons)
        
        # Mostrar receta para valorar
        recipe_name = selected_recipe.get("nombre", "Receta sin nombre")
        macros = selected_recipe.get("macros_por_porcion", {})
        ingredients = selected_recipe.get("ingredientes", [])
        
        rating_text = f"""
‚≠ê **VALORAR RECETA ESPEC√çFICA**

üìã **Receta:** {recipe_name}
üéØ **Timing:** {selected_recipe.get("categoria_timing", "general").replace("_", " ").title()}
üî• **Calor√≠as:** {macros.get("calorias", 0)} kcal
ü•© **Macros:** {macros.get("proteinas", 0)}P ‚Ä¢ {macros.get("carbohidratos", 0)}C ‚Ä¢ {macros.get("grasas", 0)}F

üõí **Ingredientes principales:**
"""
        
        # Mostrar hasta 5 ingredientes principales
        for ingredient in ingredients[:5]:
            name = ingredient.get("nombre", "")
            quantity = ingredient.get("cantidad", 0)
            unit = ingredient.get("unidad", "")
            rating_text += f"‚Ä¢ {name} ({quantity}{unit})\n"
        
        if len(ingredients) > 5:
            rating_text += f"‚Ä¢ ... y {len(ingredients) - 5} ingredientes m√°s\n"
        
        rating_text += f"""

üí≠ **¬øC√≥mo valorar√≠as esta receta?**

‚≠ê = Muy mala ‚Ä¢ ‚≠ê‚≠ê = Mala ‚Ä¢ ‚≠ê‚≠ê‚≠ê = Regular ‚Ä¢ ‚≠ê‚≠ê‚≠ê‚≠ê = Buena ‚Ä¢ ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê = Excelente

**Tu valoraci√≥n ayuda a la IA a aprender tus preferencias autom√°ticamente.**
"""
        
        bot.send_message(
            call.message.chat.id,
            rating_text,
            parse_mode='Markdown',
            reply_markup=keyboard
        )
        
        bot.answer_callback_query(call.id, f"‚úÖ Seleccionada: {recipe_name[:20]}...")
        
    except Exception as e:
        logger.error(f"Error in rate recipe callback: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando selecci√≥n")

@bot.callback_query_handler(func=lambda call: call.data.startswith('rating_'))
def handle_rating_callback(call):
    """Manejar callbacks de valoraci√≥n espec√≠fica"""
    telegram_id = str(call.from_user.id)
    
    try:
        # Extraer datos: rating_recipeIndex_rating
        parts = call.data.replace('rating_', '').split('_')
        recipe_index = int(parts[0])
        rating = int(parts[1])
        
        user_profile = meal_bot.get_user_profile(telegram_id)
        if not user_profile:
            bot.answer_callback_query(call.id, "‚ùå Error: Perfil no encontrado")
            return
        
        recent_recipes = user_profile.get("recent_generated_recipes", [])
        if recipe_index >= len(recent_recipes):
            bot.answer_callback_query(call.id, "‚ùå Receta no encontrada")
            return
        
        selected_recipe = recent_recipes[-(recipe_index + 1)]
        
        # Aplicar aprendizaje con la inteligencia de recetas
        learning_result = meal_bot.recipe_intelligence.learn_from_rating(
            user_profile, selected_recipe, rating, ""
        )
        
        if learning_result["success"]:
            # Guardar perfil actualizado
            meal_bot.database.save_user_profile(telegram_id, user_profile)
            
            # Crear respuesta de confirmaci√≥n
            stars = "‚≠ê" * rating
            recipe_name = selected_recipe.get("nombre", "Receta")
            intelligence_score = learning_result["intelligence_score"]
            
            confirmation_text = f"""
‚úÖ **VALORACI√ìN REGISTRADA**

üìã **Receta:** {recipe_name}
‚≠ê **Tu valoraci√≥n:** {stars} ({rating}/5)
üß† **IA Score actualizado:** {intelligence_score}/100

üéØ **APRENDIZAJES DE ESTA VALORACI√ìN:**
"""
            
            # Mostrar insights del aprendizaje
            learning_results = learning_result["learning_results"]
            
            if "ingredient_insights" in learning_results:
                insights = learning_results["ingredient_insights"]
                if insights.get("ingredients_affected", 0) > 0:
                    confirmation_text += f"‚Ä¢ Ingredientes analizados: {insights['ingredients_affected']}\n"
            
            if "method_insights" in learning_results:
                insights = learning_results["method_insights"]
                if insights.get("methods_detected"):
                    methods = ", ".join(insights["methods_detected"])
                    confirmation_text += f"‚Ä¢ M√©todos detectados: {methods}\n"
            
            # Recomendaciones actualizadas
            recommendations = learning_result["updated_recommendations"]
            if recommendations.get("recommended_ingredients"):
                top_ingredients = recommendations["recommended_ingredients"][:3]
                confirmation_text += f"‚Ä¢ Ingredientes ahora favoritos: {', '.join(top_ingredients)}\n"
            
            confirmation_text += f"""

üí° **IMPACTO EN FUTURAS RECOMENDACIONES:**
‚Ä¢ Las recetas similares ser√°n {'priorizadas' if rating >= 4 else 'penalizadas' if rating <= 2 else 'neutras'}
‚Ä¢ Los ingredientes de esta receta {'suben' if rating >= 4 else 'bajan' if rating <= 2 else 'mantienen'} su puntuaci√≥n
‚Ä¢ El sistema aprende autom√°ticamente de tu feedback

üöÄ **PR√ìXIMOS PASOS:**
‚Ä¢ Genera m√°s recetas con `/generar` para ver mejoras
‚Ä¢ Crea plan semanal con `/nueva_semana` m√°s personalizado
‚Ä¢ Ve tu reporte completo con el bot√≥n de abajo
"""
            
            # Crear bot√≥n para ver reporte completo
            keyboard = types.InlineKeyboardMarkup(row_width=1)
            keyboard.add(
                types.InlineKeyboardButton("üß† Ver Reporte Completo IA", callback_data="show_intelligence_report"),
                types.InlineKeyboardButton("‚≠ê Valorar Otra Receta", callback_data="back_to_rating")
            )
            
            bot.send_message(
                call.message.chat.id,
                confirmation_text,
                parse_mode='Markdown',
                reply_markup=keyboard
            )
            
            bot.answer_callback_query(call.id, f"‚úÖ {stars} registrado - IA actualizada!")
            
        else:
            bot.answer_callback_query(call.id, "‚ùå Error registrando valoraci√≥n")
            
    except Exception as e:
        logger.error(f"Error in rating callback: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando valoraci√≥n")

@bot.callback_query_handler(func=lambda call: call.data == 'show_intelligence_report')
def handle_intelligence_report_callback(call):
    """Mostrar reporte completo de inteligencia"""
    telegram_id = str(call.from_user.id)
    
    try:
        user_profile = meal_bot.get_user_profile(telegram_id)
        if not user_profile:
            bot.answer_callback_query(call.id, "‚ùå Error: Perfil no encontrado")
            return
        
        intelligence_profile = user_profile.get("recipe_intelligence", {})
        
        # Generar reporte completo
        report = meal_bot.recipe_intelligence.format_intelligence_report_for_telegram(
            intelligence_profile, user_profile
        )
        
        meal_bot.send_long_message(
            call.message.chat.id,
            report,
            parse_mode='Markdown'
        )
        
        bot.answer_callback_query(call.id, "üìä Reporte de IA generado")
        
    except Exception as e:
        logger.error(f"Error showing intelligence report: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error generando reporte")

@bot.callback_query_handler(func=lambda call: call.data == 'back_to_rating')
def handle_back_to_rating_callback(call):
    """Volver a la pantalla de valoraci√≥n"""
    telegram_id = str(call.from_user.id)
    
    # Simular comando valorar_receta
    class MockMessage:
        def __init__(self, chat_id, from_user_id):
            self.chat = type('obj', (object,), {'id': chat_id})
            self.from_user = type('obj', (object,), {'id': from_user_id})
            self.text = "/valorar_receta"
    
    mock_message = MockMessage(call.message.chat.id, call.from_user.id)
    valorar_receta_command(mock_message)
    
    bot.answer_callback_query(call.id, "üîÑ Volviendo a valoraciones...")

@bot.callback_query_handler(func=lambda call: call.data.startswith('progress_'))
def handle_progress_callback(call):
    """Manejar callbacks del sistema de progreso"""
    telegram_id = str(call.from_user.id)
    
    try:
        action = call.data.replace('progress_', '')
        user_profile = meal_bot.get_user_profile(telegram_id)
        
        if not user_profile:
            bot.answer_callback_query(call.id, "‚ùå Error: Perfil no encontrado")
            return
        
        if action in ["report", "week", "month"]:
            # Generar reporte de progreso
            period_map = {"report": "month", "week": "week", "month": "month"}
            period = period_map[action]
            
            # Mostrar mensaje de generaci√≥n
            processing_msg = bot.send_message(
                call.message.chat.id,
                "üìä **Generando reporte de progreso...**\n\n"
                "üìà Analizando tus m√©tricas\n"
                "üéØ Calculando tendencias\n"
                "üí° Generando insights personalizados\n\n"
                "*Esto puede tomar unos segundos...*",
                parse_mode='Markdown'
            )
            
            report = meal_bot.progress_tracker.generate_progress_report(user_profile, period)
            
            # Eliminar mensaje de procesamiento
            bot.delete_message(call.message.chat.id, processing_msg.message_id)
            
            if report["success"]:
                formatted_report = meal_bot.progress_tracker.format_progress_report_for_telegram(
                    report, user_profile
                )
                
                meal_bot.send_long_message(
                    call.message.chat.id,
                    formatted_report,
                    parse_mode='Markdown'
                )
                
                bot.answer_callback_query(call.id, f"üìä Reporte {period} generado")
            else:
                bot.send_message(
                    call.message.chat.id,
                    f"‚ùå **Error generando reporte:** {report.get('error', 'Error desconocido')}",
                    parse_mode='Markdown'
                )
                bot.answer_callback_query(call.id, "‚ùå Error generando reporte")
        
        elif action == "record":
            # Mostrar opciones de m√©tricas para registrar
            keyboard = types.InlineKeyboardMarkup(row_width=2)
            
            # M√©tricas principales
            keyboard.add(
                types.InlineKeyboardButton("‚öñÔ∏è Peso", callback_data="metric_weight"),
                types.InlineKeyboardButton("üìä % Grasa", callback_data="metric_body_fat")
            )
            keyboard.add(
                types.InlineKeyboardButton("üí™ Masa Muscular", callback_data="metric_muscle_mass"),
                types.InlineKeyboardButton("üìè Cintura", callback_data="metric_waist_circumference")
            )
            keyboard.add(
                types.InlineKeyboardButton("‚ö° Energ√≠a", callback_data="metric_energy_level"),
                types.InlineKeyboardButton("üí§ Sue√±o", callback_data="metric_sleep_quality")
            )
            keyboard.add(
                types.InlineKeyboardButton("üîÑ Recuperaci√≥n", callback_data="metric_recovery_rate"),
                types.InlineKeyboardButton("üçΩÔ∏è Apetito", callback_data="metric_appetite")
            )
            
            bot.send_message(
                call.message.chat.id,
                "üìà **REGISTRAR M√âTRICA**\n\n"
                "**Selecciona la m√©trica que quieres registrar:**\n\n"
                "‚öñÔ∏è **Peso** - Peso corporal en kg\n"
                "üìä **% Grasa** - Porcentaje de grasa corporal\n"
                "üí™ **Masa Muscular** - Masa muscular en kg\n"
                "üìè **Cintura** - Circunferencia de cintura en cm\n"
                "‚ö° **Energ√≠a** - Nivel de energ√≠a (1-10)\n"
                "üí§ **Sue√±o** - Calidad de sue√±o (1-10)\n"
                "üîÑ **Recuperaci√≥n** - Recuperaci√≥n post-entreno (1-10)\n"
                "üçΩÔ∏è **Apetito** - Control del apetito (1-10)",
                parse_mode='Markdown',
                reply_markup=keyboard
            )
            
            bot.answer_callback_query(call.id, "üìà Selecciona m√©trica a registrar")
        
        elif action == "goals":
            # Configurar objetivos (funcionalidad futura)
            bot.send_message(
                call.message.chat.id,
                "üéØ **CONFIGURACI√ìN DE OBJETIVOS**\n\n"
                "üöß Esta funcionalidad estar√° disponible pr√≥ximamente.\n\n"
                "**Por ahora puedes:**\n"
                "‚Ä¢ Registrar m√©tricas regularmente\n"
                "‚Ä¢ Ver reportes de progreso\n"
                "‚Ä¢ Seguir las recomendaciones autom√°ticas\n\n"
                "El sistema aprende autom√°ticamente de tus datos y ajusta las recomendaciones.",
                parse_mode='Markdown'
            )
            
            bot.answer_callback_query(call.id, "üöß Pr√≥ximamente disponible")
        
        elif action == "help":
            # Ayuda del sistema de progreso
            help_text = """
üìä **C√ìMO FUNCIONA EL SISTEMA DE PROGRESO**

üéØ **OBJETIVO:**
Trackear autom√°ticamente tu progreso hacia tus objetivos nutricionales y de fitness.

üìà **PROCESO:**
1Ô∏è‚É£ **Registras m√©tricas** (peso, energ√≠a, etc.)
2Ô∏è‚É£ **El sistema analiza** tendencias autom√°ticamente
3Ô∏è‚É£ **Recibes insights** personalizados con IA
4Ô∏è‚É£ **Se ajusta tu plan** seg√∫n el progreso

üí° **BENEFICIOS:**
‚Ä¢ **An√°lisis autom√°tico** de tendencias
‚Ä¢ **Detecci√≥n de patrones** en tu progreso
‚Ä¢ **Recomendaciones adaptativas** seg√∫n datos
‚Ä¢ **Ajustes autom√°ticos** del Available Energy
‚Ä¢ **Insights personalizados** con IA

üìä **M√âTRICAS DISPONIBLES:**
‚öñÔ∏è **F√≠sicas:** Peso, grasa, masa muscular, cintura
‚ö° **Bienestar:** Energ√≠a, sue√±o, recuperaci√≥n, apetito

üî¨ **AN√ÅLISIS INCLUIDO:**
‚Ä¢ Tendencias semanales/mensuales
‚Ä¢ Comparaciones con objetivos
‚Ä¢ Detecci√≥n de correlaciones
‚Ä¢ Predicciones de progreso

üöÄ **PR√ìXIMOS PASOS:**
‚Ä¢ Registra tu primera m√©trica
‚Ä¢ Usa `/progreso` regularmente
‚Ä¢ Sigue las recomendaciones autom√°ticas
"""
            
            meal_bot.send_long_message(
                call.message.chat.id,
                help_text,
                parse_mode='Markdown'
            )
            
            bot.answer_callback_query(call.id, "‚ÑπÔ∏è Informaci√≥n mostrada")
        
    except Exception as e:
        logger.error(f"Error in progress callback: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando acci√≥n")

@bot.callback_query_handler(func=lambda call: call.data.startswith('metric_'))
def handle_metric_callback(call):
    """Manejar callbacks de selecci√≥n de m√©trica espec√≠fica"""
    telegram_id = str(call.from_user.id)
    
    try:
        metric_name = call.data.replace('metric_', '')
        user_profile = meal_bot.get_user_profile(telegram_id)
        
        if not user_profile:
            bot.answer_callback_query(call.id, "‚ùå Error: Perfil no encontrado")
            return
        
        # Generar ayuda para entrada de m√©trica
        help_text = meal_bot.progress_tracker.get_metric_entry_keyboard(metric_name)
        
        # Configurar estado para entrada de m√©trica
        meal_bot.user_states[telegram_id] = {
            "state": "metric_entry",
            "metric_name": metric_name,
            "step": "value"
        }
        
        bot.send_message(
            call.message.chat.id,
            help_text,
            parse_mode='Markdown'
        )
        
        metric_config = meal_bot.progress_tracker.trackable_metrics.get(metric_name, {})
        metric_display_name = metric_config.get("name", "M√©trica")
        
        bot.answer_callback_query(call.id, f"üìù Registrando {metric_display_name}")
        
    except Exception as e:
        logger.error(f"Error in metric callback: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando m√©trica")

@bot.callback_query_handler(func=lambda call: call.data.startswith('edit_'))
def handle_edit_profile_callback(call):
    """Manejar callbacks de edici√≥n de perfil"""
    telegram_id = str(call.from_user.id)
    
    if call.data == "cancel_edit":
        bot.edit_message_text(
            "‚ùå **Edici√≥n cancelada**\n\nTus preferencias no han sido modificadas.",
            call.message.chat.id,
            call.message.message_id,
            parse_mode='Markdown'
        )
        bot.answer_callback_query(call.id, "Edici√≥n cancelada")
        return
    
    # Mapear callback a secci√≥n de preferencias
    edit_sections = {
        "edit_liked_foods": {
            "section": "liked_foods",
            "title": "üçΩÔ∏è ALIMENTOS PREFERIDOS",
            "step": "9C",
            "description": "Selecciona los alimentos que m√°s te gustan. Puedes elegir m√∫ltiples opciones:"
        },
        "edit_disliked_foods": {
            "section": "disliked_foods", 
            "title": "üö´ ALIMENTOS A EVITAR",
            "step": "9D",
            "description": "Selecciona alimentos que prefieres evitar. Puedes elegir m√∫ltiples opciones:"
        },
        "edit_cooking_methods": {
            "section": "cooking_methods",
            "title": "üë®‚Äçüç≥ M√âTODOS DE COCCI√ìN",
            "step": "9F", 
            "description": "Selecciona tus m√©todos de cocci√≥n preferidos. Puedes elegir m√∫ltiples opciones:"
        },
        "edit_training_schedule": {
            "section": "training_schedule",
            "title": "‚è∞ HORARIO DE ENTRENAMIENTO",
            "step": "7",
            "description": "Selecciona tu horario habitual de entrenamiento:"
        }
    }
    
    section_data = edit_sections.get(call.data)
    if not section_data:
        bot.answer_callback_query(call.id, "‚ùå Opci√≥n no v√°lida", show_alert=True)
        return
    
    # Configurar estado de edici√≥n
    meal_bot.user_states[telegram_id] = {
        "state": "profile_edit",
        "step": section_data["step"],
        "edit_section": section_data["section"],
        "data": {}
    }
    
    bot.answer_callback_query(call.id, f"Editando {section_data['title']}")
    
    # Redirigir al paso espec√≠fico de configuraci√≥n
    if section_data["step"] == "9C":
        handle_edit_liked_foods(call.message, telegram_id)
    elif section_data["step"] == "9D":
        handle_edit_disliked_foods(call.message, telegram_id)
    elif section_data["step"] == "9F":
        handle_edit_cooking_methods(call.message, telegram_id)
    elif section_data["step"] == "7":
        handle_edit_training_schedule(call.message, telegram_id)

def handle_edit_liked_foods(message, telegram_id):
    """Manejar edici√≥n de alimentos preferidos"""
    # Obtener preferencias actuales
    user_profile = meal_bot.get_user_profile(telegram_id)
    current_liked = user_profile.get("preferences", {}).get("liked_foods", [])
    
    # Reutilizar l√≥gica del paso 9C del setup inicial
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    
    food_options = [
        "ü•© Carnes rojas", "üêî Aves", "üêü Pescados", "ü•ö Huevos",
        "ü•õ L√°cteos", "ü•ú Frutos secos", "ü´ò Legumbres", "ü•¨ Hojas verdes",
        "ü•¶ Cruc√≠feras", "üçÖ Solan√°ceas", "üåø Arom√°ticas", "ü•ï Ra√≠ces",
        "üå∂Ô∏è Pimientos", "ü•í Pepin√°ceas", "ü´í Aceitunas", "ü•ë Aguacate",
        "‚û°Ô∏è Continuar"
    ]
    
    buttons = [types.KeyboardButton(option) for option in food_options]
    markup.add(*buttons)
    
    selected_text = f"**Actualmente seleccionados:** {', '.join(current_liked) if current_liked else 'Ninguno'}"
    
    bot.edit_message_text(
        f"üçΩÔ∏è **EDITANDO ALIMENTOS PREFERIDOS**\n\n"
        f"Selecciona los alimentos que m√°s te gustan. Puedes elegir m√∫ltiples opciones.\n\n"
        f"{selected_text}\n\n"
        f"üí° Selecciona una opci√≥n o usa **‚û°Ô∏è Continuar** para finalizar.",
        message.chat.id,
        message.message_id,
        parse_mode='Markdown',
        reply_markup=markup
    )

def handle_edit_disliked_foods(message, telegram_id):
    """Manejar edici√≥n de alimentos a evitar"""
    user_profile = meal_bot.get_user_profile(telegram_id)
    current_disliked = user_profile.get("preferences", {}).get("disliked_foods", [])
    
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    
    food_options = [
        "ü•© Carnes rojas", "üêî Aves", "üêü Pescados", "ü•ö Huevos",
        "ü•õ L√°cteos", "ü•ú Frutos secos", "ü´ò Legumbres", "ü•¨ Hojas verdes",
        "ü•¶ Cruc√≠feras", "üçÖ Solan√°ceas", "üåø Arom√°ticas", "ü•ï Ra√≠ces",
        "üå∂Ô∏è Pimientos", "ü•í Pepin√°ceas", "ü´í Aceitunas", "ü•ë Aguacate",
        "‚û°Ô∏è Continuar"
    ]
    
    buttons = [types.KeyboardButton(option) for option in food_options]
    markup.add(*buttons)
    
    selected_text = f"**Actualmente evitados:** {', '.join(current_disliked) if current_disliked else 'Ninguno'}"
    
    bot.edit_message_text(
        f"üö´ **EDITANDO ALIMENTOS A EVITAR**\n\n"
        f"Selecciona alimentos que prefieres evitar. Puedes elegir m√∫ltiples opciones.\n\n"
        f"{selected_text}\n\n"
        f"üí° Selecciona una opci√≥n o usa **‚û°Ô∏è Continuar** para finalizar.",
        message.chat.id,
        message.message_id,
        parse_mode='Markdown',
        reply_markup=markup
    )

def handle_edit_cooking_methods(message, telegram_id):
    """Manejar edici√≥n de m√©todos de cocci√≥n"""
    user_profile = meal_bot.get_user_profile(telegram_id)
    current_methods = user_profile.get("preferences", {}).get("cooking_methods", [])
    
    markup = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
    
    cooking_options = [
        "üî• Horno", "üç≥ Sart√©n", "ü•ò Plancha", "ü´ï Vapor",
        "ü•ó Crudo/Ensaladas", "üç≤ Guisado", "üî• Parrilla", "ü•Ñ Hervido",
        "‚û°Ô∏è Continuar"
    ]
    
    buttons = [types.KeyboardButton(option) for option in cooking_options]
    markup.add(*buttons)
    
    selected_text = f"**Actualmente seleccionados:** {', '.join(current_methods) if current_methods else 'Ninguno'}"
    
    bot.edit_message_text(
        f"üë®‚Äçüç≥ **EDITANDO M√âTODOS DE COCCI√ìN**\n\n"
        f"Selecciona tus m√©todos de cocci√≥n preferidos. Puedes elegir m√∫ltiples opciones.\n\n"
        f"{selected_text}\n\n"
        f"üí° Selecciona una opci√≥n o usa **‚û°Ô∏è Continuar** para finalizar.",
        message.chat.id,
        message.message_id,
        parse_mode='Markdown',
        reply_markup=markup
    )

def handle_edit_training_schedule(message, telegram_id):
    """Manejar edici√≥n de horario de entrenamiento"""
    user_profile = meal_bot.get_user_profile(telegram_id)
    current_schedule = user_profile.get("exercise_profile", {}).get("training_schedule_desc", "No especificado")
    
    markup = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
    
    schedule_options = [
        "üåÖ Ma√±ana (6:00-12:00)",
        "‚òÄÔ∏è Mediod√≠a (12:00-16:00)", 
        "üåÜ Tarde (16:00-20:00)",
        "üåô Noche (20:00-24:00)",
        "üîÑ Variable/Cambia"
    ]
    
    buttons = [types.KeyboardButton(option) for option in schedule_options]
    markup.add(*buttons)
    
    bot.edit_message_text(
        f"‚è∞ **EDITANDO HORARIO DE ENTRENAMIENTO**\n\n"
        f"¬øCu√°ndo sueles entrenar habitualmente?\n\n"
        f"**Horario actual:** {current_schedule}\n\n"
        f"Selecciona tu nuevo horario:",
        message.chat.id,
        message.message_id,
        parse_mode='Markdown',
        reply_markup=markup
    )

def create_favorite_buttons(telegram_id: str, recipe_id: str) -> types.InlineKeyboardMarkup:
    """Crear botones de favoritos para una receta"""
    user_profile = meal_bot.get_user_profile(telegram_id)
    is_favorite = meal_bot.profile_system.is_recipe_favorite(user_profile, recipe_id)
    
    markup = types.InlineKeyboardMarkup(row_width=2)
    
    if is_favorite:
        # Bot√≥n para quitar de favoritos
        markup.add(
            types.InlineKeyboardButton("üö´ Quitar de favoritos", callback_data=f"fav_remove_{recipe_id}"),
            types.InlineKeyboardButton("‚≠ê Ver favoritas", callback_data="fav_view_all")
        )
    else:
        # Bot√≥n para a√±adir a favoritos
        markup.add(
            types.InlineKeyboardButton("‚≠ê A√±adir a favoritos", callback_data=f"fav_add_{recipe_id}"),
            types.InlineKeyboardButton("üìö Ver favoritas", callback_data="fav_view_all")
        )
    
    return markup

@bot.callback_query_handler(func=lambda call: call.data.startswith('fav_'))
def handle_favorite_callback(call):
    """Manejar callbacks de favoritos"""
    telegram_id = str(call.from_user.id)
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    if not user_profile:
        bot.answer_callback_query(call.id, "‚ùå Configura tu perfil primero", show_alert=True)
        return
    
    if call.data == "fav_view_all":
        # Mostrar todas las favoritas
        bot.answer_callback_query(call.id, "üìö Mostrando favoritas...")
        favoritas_command(call.message)
        return
    
    # Extraer acci√≥n y recipe_id
    parts = call.data.split('_', 2)
    if len(parts) != 3:
        bot.answer_callback_query(call.id, "‚ùå Comando no v√°lido", show_alert=True)
        return
    
    action = parts[1]  # 'add' o 'remove'
    recipe_id = parts[2]
    
    try:
        if action == "add":
            # A√±adir a favoritos
            meal_bot.profile_system.add_to_favorites(user_profile, recipe_id)
            meal_bot.data["users"][telegram_id] = user_profile
            meal_bot.save_data()
            
            bot.answer_callback_query(call.id, "‚≠ê A√±adido a favoritos!", show_alert=False)
            
            # Actualizar botones
            new_markup = create_favorite_buttons(telegram_id, recipe_id)
            try:
                bot.edit_message_reply_markup(
                    call.message.chat.id,
                    call.message.message_id,
                    reply_markup=new_markup
                )
            except:
                pass  # Si no se puede editar, continuar
            
        elif action == "remove":
            # Quitar de favoritos
            meal_bot.profile_system.remove_from_favorites(user_profile, recipe_id)
            meal_bot.data["users"][telegram_id] = user_profile
            meal_bot.save_data()
            
            bot.answer_callback_query(call.id, "üö´ Quitado de favoritos", show_alert=False)
            
            # Actualizar botones
            new_markup = create_favorite_buttons(telegram_id, recipe_id)
            try:
                bot.edit_message_reply_markup(
                    call.message.chat.id,
                    call.message.message_id,
                    reply_markup=new_markup
                )
            except:
                pass  # Si no se puede editar, continuar
        
    except Exception as e:
        bot.answer_callback_query(call.id, f"‚ùå Error: {str(e)}", show_alert=True)

@bot.callback_query_handler(func=lambda call: call.data.startswith('gen_'))
def handle_generation_callback(call):
    """Manejar callbacks de generaci√≥n de m√∫ltiples opciones de recetas"""
    telegram_id = str(call.from_user.id)
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    if not user_profile:
        bot.answer_callback_query(call.id, "‚ùå Configura tu perfil primero", show_alert=True)
        return
    
    # Mapear callback a par√°metros
    timing_map = {
        "gen_pre_entreno": {
            "timing_category": "pre_entreno",
            "function_category": "energia_rapida",
            "target_macros": {"protein": 10, "carbs": 35, "fat": 5, "calories": 210}
        },
        "gen_post_entreno": {
            "timing_category": "post_entreno", 
            "function_category": "sintesis_proteica",
            "target_macros": {"protein": 35, "carbs": 30, "fat": 8, "calories": 320}
        },
        "gen_desayuno": {
            "timing_category": "desayuno",
            "function_category": "equilibrio_nutricional",
            "target_macros": {"protein": 25, "carbs": 45, "fat": 15, "calories": 380}
        },
        "gen_almuerzo": {
            "timing_category": "almuerzo",
            "function_category": "equilibrio_nutricional",
            "target_macros": {"protein": 40, "carbs": 50, "fat": 20, "calories": 480}
        },
        "gen_merienda": {
            "timing_category": "merienda",
            "function_category": "micronutrientes", 
            "target_macros": {"protein": 15, "carbs": 20, "fat": 12, "calories": 220}
        },
        "gen_cena": {
            "timing_category": "cena",
            "function_category": "equilibrio_nutricional",
            "target_macros": {"protein": 35, "carbs": 25, "fat": 18, "calories": 360}
        }
    }
    
    # Limpiar callback data para manejar "_more_timestamp"
    clean_callback = call.data.split('_more_')[0]
    
    request_data = timing_map.get(clean_callback)
    if not request_data:
        bot.answer_callback_query(call.id, "‚ùå Opci√≥n no v√°lida", show_alert=True)
        return
    
    # Si es una solicitud de "m√°s opciones", agregar indicador de variabilidad
    is_more_request = '_more_' in call.data
    if is_more_request:
        # Agregar timestamp para forzar variabilidad en el prompt
        request_data = request_data.copy()
        request_data['variability_seed'] = call.data.split('_more_')[1]
        request_data['generation_type'] = 'more_options'
    
    bot.answer_callback_query(call.id, "ü§ñ Generando 5 opciones personalizadas...")
    
    # Mensaje de procesamiento
    timing_display = {
        "pre_entreno": "‚ö° PRE-ENTRENO",
        "post_entreno": "üí™ POST-ENTRENO",
        "desayuno": "üåÖ DESAYUNO",
        "almuerzo": "üçΩÔ∏è ALMUERZO",
        "merienda": "ü•ú MERIENDA",
        "cena": "üåô CENA"
    }.get(request_data['timing_category'], request_data['timing_category'].upper())
    
    processing_msg = bot.send_message(
        call.message.chat.id,
        f"ü§ñ **GENERANDO 5 OPCIONES PARA {timing_display}**\n\n"
        f"üìä **Macros objetivo:** {request_data['target_macros']['calories']} kcal por opci√≥n\n"
        f"üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}\n\n"
        "‚è≥ Procesando con IA...\n"
        "üé® Creando variedad de ingredientes...\n"
        "üë®‚Äçüç≥ Variando t√©cnicas de cocci√≥n...\n"
        "üß¨ Adaptando a tus preferencias...\n"
        "‚úÖ Validando calidad nutricional...\n\n"
        "*Esto puede tomar 10-15 segundos...*",
        parse_mode='Markdown'
    )
    
    try:
        # Generar m√∫ltiples opciones con IA
        result = meal_bot.ai_generator.generate_multiple_recipes(user_profile, request_data, num_options=5)
        
        # Borrar mensaje de procesamiento
        bot.delete_message(call.message.chat.id, processing_msg.message_id)
        
        if result["success"]:
            # Importar la funci√≥n de formateo
            from ai_integration import format_multiple_recipes_for_display
            
            # Formatear opciones para display
            options_text = format_multiple_recipes_for_display(result, request_data['timing_category'])
            
            # Crear botones de selecci√≥n
            keyboard = types.InlineKeyboardMarkup(row_width=2)
            
            # Botones para cada opci√≥n
            options = result.get("options", [])
            for i, option in enumerate(options[:5], 1):  # M√°ximo 5 opciones
                recipe_name = option["recipe"]["nombre"]
                # Acortar nombre si es muy largo
                display_name = recipe_name if len(recipe_name) <= 25 else f"{recipe_name[:22]}..."
                keyboard.add(
                    types.InlineKeyboardButton(
                        f"‚úÖ Opci√≥n {i}: {display_name}", 
                        callback_data=f"select_recipe_{i}_{request_data['timing_category']}"
                    )
                )
            
            # Bot√≥n para generar m√°s opciones con timestamp para forzar variabilidad
            import time
            timestamp = int(time.time())
            keyboard.add(
                types.InlineKeyboardButton(
                    "üîÑ Generar 5 opciones nuevas", 
                    callback_data=f"{call.data}_more_{timestamp}"
                )
            )
            
            # Enviar opciones con botones
            meal_bot.send_long_message(
                call.message.chat.id, 
                options_text, 
                parse_mode='Markdown', 
                reply_markup=keyboard
            )
            
            # Guardar las opciones temporalmente para cuando el usuario seleccione
            if "temp_recipe_options" not in user_profile:
                user_profile["temp_recipe_options"] = {}
            
            user_profile["temp_recipe_options"][request_data['timing_category']] = {
                "options": options,
                "generated_at": datetime.now().isoformat(),
                "request_data": request_data
            }
            
            # Guardar en la base de datos
            meal_bot.data["users"][telegram_id] = user_profile
            meal_bot.save_data()
            
        else:
            error_msg = result.get("error", "Error desconocido")
            bot.send_message(
                call.message.chat.id,
                f"‚ùå **Error generando opciones:**\n{error_msg}\n\n"
                "üí° **Intenta:**\n"
                "‚Ä¢ Usar /generar de nuevo\n"
                "‚Ä¢ Verificar tu conexi√≥n\n"
                "‚Ä¢ Usar /buscar para b√∫squeda libre",
                parse_mode='Markdown'
            )
            
    except Exception as e:
        logger.error(f"Error in multiple recipe generation: {e}")
        try:
            bot.delete_message(call.message.chat.id, processing_msg.message_id)
        except:
            pass
        bot.send_message(
            call.message.chat.id,
            "‚ùå **Error t√©cnico** generando las opciones.\n"
            "Int√©ntalo de nuevo en unos momentos.",
            parse_mode='Markdown'
        )

@bot.callback_query_handler(func=lambda call: call.data.startswith('select_recipe_'))
def handle_recipe_selection_callback(call):
    """Manejar la selecci√≥n de una receta espec√≠fica de las m√∫ltiples opciones"""
    telegram_id = str(call.from_user.id)
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    if not user_profile:
        bot.answer_callback_query(call.id, "‚ùå Configura tu perfil primero", show_alert=True)
        return
    
    try:
        # Parsear callback data: select_recipe_{option_number}_{timing_category}
        parts = call.data.split('_')
        if len(parts) != 4:
            bot.answer_callback_query(call.id, "‚ùå Formato de callback inv√°lido", show_alert=True)
            return
        
        option_number = int(parts[2])
        timing_category = parts[3]
        
        # Obtener opciones temporales guardadas
        temp_options = user_profile.get("temp_recipe_options", {}).get(timing_category)
        if not temp_options:
            bot.answer_callback_query(call.id, "‚ùå Opciones expiradas. Genera nuevas opciones.", show_alert=True)
            return
        
        options = temp_options.get("options", [])
        if option_number < 1 or option_number > len(options):
            bot.answer_callback_query(call.id, "‚ùå Opci√≥n no v√°lida", show_alert=True)
            return
        
        # Obtener la receta seleccionada
        selected_option = options[option_number - 1]
        recipe = selected_option["recipe"]
        validation = selected_option["validation"]
        request_data = temp_options["request_data"]
        
        bot.answer_callback_query(call.id, f"‚úÖ Opci√≥n {option_number} seleccionada!")
        
        # Guardar receta en el perfil del usuario
        save_success = meal_bot.save_generated_recipe(telegram_id, recipe, timing_category, validation)
        
        # Formatear receta completa para mostrar
        from ai_integration import format_recipe_for_display
        recipe_text = format_recipe_for_display(recipe, validation)
        
        # Mensaje de confirmaci√≥n simple con nombre de la receta
        recipe_name = recipe.get("nombre", "Receta")
        confirmation_message = f"‚úÖ {recipe_name} guardada en tu historial"
        
        success_text = confirmation_message
        
        # Limpiar opciones temporales despu√©s de la selecci√≥n
        if "temp_recipe_options" in user_profile:
            if timing_category in user_profile["temp_recipe_options"]:
                del user_profile["temp_recipe_options"][timing_category]
            
            # Guardar cambios
            meal_bot.data["users"][telegram_id] = user_profile
            meal_bot.save_data()
        
        # Enviar mensaje de confirmaci√≥n simple (sin submen√∫)
        bot.send_message(
            call.message.chat.id, 
            success_text, 
            parse_mode='Markdown'
        )
        
        # Sistema de aprendizaje: registrar la selecci√≥n y rechazos
        if hasattr(meal_bot, 'recipe_intelligence'):
            try:
                # Registrar la receta seleccionada (valoraci√≥n positiva impl√≠cita)
                selection_result = meal_bot.recipe_intelligence.register_recipe_selection(
                    telegram_id, 
                    recipe, 
                    timing_category,
                    option_number,
                    len(options),
                    user_profile
                )
                
                # Registrar las opciones no seleccionadas (valoraci√≥n negativa impl√≠cita)
                all_recipes = [opt["recipe"] for opt in options]
                rejection_result = meal_bot.recipe_intelligence.register_recipe_rejection(
                    telegram_id,
                    all_recipes,
                    option_number,
                    timing_category,
                    user_profile
                )
                
                logger.info(f"Learning system updated: selection={selection_result.get('success')}, rejections={rejection_result.get('success')}")
                
                # Guardar el perfil actualizado con los aprendizajes
                if selection_result.get('success'):
                    meal_bot.database.save_user_profile(telegram_id, user_profile)
                
            except Exception as e:
                logger.error(f"Error registering recipe learning: {e}")
        
    except ValueError:
        bot.answer_callback_query(call.id, "‚ùå N√∫mero de opci√≥n inv√°lido", show_alert=True)
    except Exception as e:
        logger.error(f"Error handling recipe selection: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando selecci√≥n", show_alert=True)

@bot.callback_query_handler(func=lambda call: call.data.startswith('schedule_'))
def handle_schedule_callback(call):
    """Manejar callbacks de selecci√≥n de cronograma"""
    telegram_id = str(call.from_user.id)
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    if not user_profile:
        bot.answer_callback_query(call.id, "‚ùå Configura tu perfil primero", show_alert=True)
        return
    
    # Extraer el tipo de cronograma seleccionado
    schedule_type = call.data.replace('schedule_', '')
    
    # Verificar que el cronograma existe
    schedule_data = meal_bot.data['cooking_schedules'].get(schedule_type, {})
    
    if not schedule_data:
        bot.answer_callback_query(call.id, "‚ùå Cronograma no encontrado", show_alert=True)
        return
    
    # Guardar la selecci√≥n en el perfil del usuario
    if 'settings' not in user_profile:
        user_profile['settings'] = {}
    user_profile['settings']['cooking_schedule'] = schedule_type
    meal_bot.save_data()
    
    bot.answer_callback_query(call.id, "‚úÖ Cronograma seleccionado")
    
    # Mostrar el cronograma seleccionado
    response_text = f"""
‚è∞ **CRONOGRAMA DE COCCI√ìN SEMANAL**

üéØ **Tu cronograma:** {schedule_data.get('name', 'Personalizado')}
üìù **Descripci√≥n:** {schedule_data.get('description', 'Cronograma optimizado')}
‚è±Ô∏è **Tiempo estimado:** {schedule_data.get('estimated_time', 'Variable')}

**SESIONES PLANIFICADAS:**
"""
    
    sessions = schedule_data.get('sessions', [])
    for i, session in enumerate(sessions, 1):
        day = session.get('day', 'd√≠a').title()
        duration = session.get('duration', '2-3 horas')
        start_time = session.get('start_time', '10:00')
        tasks = session.get('tasks', [])
        
        response_text += f"""
**SESI√ìN {i} - {day}**
üïê Horario: {start_time}
‚è∞ Duraci√≥n: {duration}
üìã Tareas:
"""
        for task in tasks:
            response_text += f"‚Ä¢ {task.replace('_', ' ').title()}\n"
    
    # Ventajas/desventajas
    pros = schedule_data.get('pros', [])
    cons = schedule_data.get('cons', [])
    
    if pros:
        response_text += "\n‚úÖ **VENTAJAS:**\n"
        for pro in pros:
            response_text += f"‚Ä¢ {pro}\n"
    
    if cons:
        response_text += "\n‚ö†Ô∏è **CONSIDERACIONES:**\n"
        for con in cons:
            response_text += f"‚Ä¢ {con}\n"
    
    response_text += f"""

üí° **OPTIMIZACI√ìN SEG√öN TU PERFIL:**
‚Ä¢ Objetivo: {user_profile['basic_data']['objetivo_descripcion']}
‚Ä¢ Available Energy: {user_profile['energy_data']['available_energy']} kcal/kg FFM/d√≠a
‚Ä¢ Macros diarios: {user_profile['macros']['calories']} kcal

**Comandos relacionados:**
‚Ä¢ /compras - Lista de compras para este cronograma
‚Ä¢ /menu - Ver distribuci√≥n nutricional semanal
‚Ä¢ /planificar_semana - Optimizaci√≥n avanzada
"""
    
    bot.edit_message_text(
        text=response_text,
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        parse_mode='Markdown'
    )

@bot.callback_query_handler(func=lambda call: call.data.startswith('select_search_recipe_'))
def handle_search_recipe_selection_callback(call):
    """Manejar selecci√≥n de receta de b√∫squeda"""
    telegram_id = str(call.from_user.id)
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    if not user_profile:
        bot.answer_callback_query(call.id, "‚ùå Configura tu perfil primero", show_alert=True)
        return
    
    # Verificar estado del usuario
    user_state = meal_bot.user_states.get(telegram_id, {})
    if user_state.get("state") != "search_results":
        bot.answer_callback_query(call.id, "‚ùå Sesi√≥n expirada. Intenta la b√∫squeda de nuevo.", show_alert=True)
        return
    
    # Extraer √≠ndice de la receta seleccionada
    recipe_index = int(call.data.replace('select_search_recipe_', ''))
    results = user_state.get("results", [])
    
    if recipe_index >= len(results):
        bot.answer_callback_query(call.id, "‚ùå Receta no encontrada", show_alert=True)
        return
    
    # Obtener la receta seleccionada
    selected_result = results[recipe_index]
    recipe = selected_result.get("adaptacion_propuesta")
    validation = selected_result.get("validation", {})
    
    if not recipe:
        bot.answer_callback_query(call.id, "‚ùå Error al obtener la receta", show_alert=True)
        return
    
    bot.answer_callback_query(call.id, f"‚úÖ Receta {recipe_index + 1} seleccionada")
    
    # Determinar categor√≠a de timing para guardar la receta
    timing_category = recipe.get("categoria_timing", "almuerzo")  # Default a almuerzo
    
    # Guardar la receta seleccionada
    success = meal_bot.save_generated_recipe(telegram_id, recipe, timing_category, validation)
    
    if success:
        response_text = f"""
‚úÖ **RECETA GUARDADA EXITOSAMENTE**

üìö **"{recipe.get('nombre', 'Receta')}"** ha sido a√±adida a tus recetas.

**¬øQu√© sigue?**
‚Ä¢ `/recetas` - Ver todas tus recetas guardadas
‚Ä¢ `/valorar_receta` - Valorar para mejorar la IA
‚Ä¢ `/generar` - Crear m√°s recetas espec√≠ficas
‚Ä¢ `/nueva_semana` - Generar plan completo

üí° **La IA aprende de tus selecciones para futuras recomendaciones.**
"""
    else:
        response_text = """
‚ùå **Error al guardar la receta**

Intenta de nuevo o contacta soporte si el problema persiste.
"""
    
    bot.edit_message_text(
        text=response_text,
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        parse_mode='Markdown'
    )
    
    # Limpiar estado del usuario
    if telegram_id in meal_bot.user_states:
        del meal_bot.user_states[telegram_id]

@bot.callback_query_handler(func=lambda call: call.data.startswith('more_search_options_'))
def handle_more_search_options_callback(call):
    """Manejar solicitud de m√°s opciones de b√∫squeda"""
    telegram_id = str(call.from_user.id)
    query = call.data.replace('more_search_options_', '')
    
    bot.answer_callback_query(call.id, "üîÑ Buscando m√°s opciones...")
    
    # Editar mensaje para mostrar que est√° procesando
    bot.edit_message_text(
        text=f"ü§ñ **Buscando m√°s opciones para:** '{query}'\n\n"
             "‚è≥ Generando nuevas recetas con IA...\n"
             "üìä Adaptando a tu perfil nutricional...",
        chat_id=call.message.chat.id,
        message_id=call.message.message_id,
        parse_mode='Markdown'
    )
    
    # Crear mensaje simulado para reutilizar la funci√≥n
    class MockMessage:
        def __init__(self, chat_id):
            self.chat = type('obj', (object,), {'id': chat_id})
    
    mock_message = MockMessage(call.message.chat.id)
    
    # Llamar a la funci√≥n de b√∫squeda
    process_ai_search(telegram_id, query, mock_message)

@bot.message_handler(commands=['compras'])
def compras_command(message):
    """Mostrar lista de compras con complementos"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    
    response_text = f"""
üõí **LISTA DE COMPRAS SEMANAL**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
üî• **Calor√≠as objetivo:** {user_profile['macros']['calories']} kcal/d√≠a

**PROTE√çNAS:**
‚Ä¢ Pechuga de pollo: 2.5 kg
‚Ä¢ Carne de res magra: 1.5 kg
‚Ä¢ Huevos frescos: 2 docenas
‚Ä¢ Salm√≥n fresco: 800g

**LEGUMBRES Y CEREALES:**
‚Ä¢ Quinoa: 500g
‚Ä¢ Arroz integral: 1 kg
‚Ä¢ Lentejas rojas: 400g
‚Ä¢ Garbanzos secos: 500g

**VEGETALES FRESCOS:**
‚Ä¢ Br√≥coli: 1 kg
‚Ä¢ Espinacas: 500g
‚Ä¢ Tomates: 1.5 kg
‚Ä¢ Pimientos: 800g
‚Ä¢ Cebolla: 1 kg

ü•ú **COMPLEMENTOS MEDITERR√ÅNEOS:**
‚Ä¢ Almendras crudas: 250g
‚Ä¢ Nueces: 200g
‚Ä¢ Yogur griego natural: 1 kg
‚Ä¢ Queso feta: 300g
‚Ä¢ Aceitunas kalamata: 200g
‚Ä¢ Miel cruda: 1 bote
‚Ä¢ Aceite oliva virgen extra: 500ml

**ESPECIAS Y HIERBAS:**
‚Ä¢ Oregano seco
‚Ä¢ Tomillo fresco
‚Ä¢ Ajo fresco
‚Ä¢ Jengibre
‚Ä¢ Comino molido

üí° **Tip:** Esta lista est√° optimizada para meal prep semanal seg√∫n tu perfil nutricional.

**Comandos relacionados:**
‚Ä¢ /cronograma - Ver cu√°ndo cocinar cada cosa
‚Ä¢ /menu - Ver c√≥mo se distribuye todo
"""
    
    meal_bot.send_long_message(message.chat.id, response_text, parse_mode='Markdown')

@bot.message_handler(commands=['cronograma'])
def cronograma_command(message):
    """Mostrar cronograma de cocci√≥n"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    if not user_profile:
        bot.send_message(message.chat.id, "‚ùå Error: No se pudo encontrar tu perfil")
        return
    
    # Obtener cronograma con valores por defecto
    cooking_schedule = user_profile.get('settings', {}).get('cooking_schedule', 'dos_sesiones')
    
    # Verificar que existan cooking_schedules en los datos
    if 'cooking_schedules' not in meal_bot.data:
        bot.send_message(
            message.chat.id,
            "‚ö†Ô∏è **CRONOGRAMA NO DISPONIBLE**\n\n"
            "Los datos de cronogramas no est√°n disponibles actualmente.\n"
            "Usa /generar para crear recetas espec√≠ficas por timing."
        )
        return
    
    # Obtener datos del cronograma
    schedule_data = meal_bot.data['cooking_schedules'].get(cooking_schedule, {})
    
    # Si no existe el cronograma espec√≠fico, mostrar opciones para elegir
    if not schedule_data:
        # Crear teclado inline para selecci√≥n de cronograma
        keyboard = types.InlineKeyboardMarkup(row_width=1)
        
        keyboard.add(
            types.InlineKeyboardButton("üéØ Sesi√≥n √∫nica (Domingo)", callback_data="schedule_sesion_unica_domingo"),
            types.InlineKeyboardButton("‚öñÔ∏è Dos sesiones (Dom + Mi√©r)", callback_data="schedule_dos_sesiones"),
            types.InlineKeyboardButton("üîÑ Tres sesiones (Dom/Mar/Vie)", callback_data="schedule_tres_sesiones"),
            types.InlineKeyboardButton("üìÖ Preparaci√≥n diaria", callback_data="schedule_preparacion_diaria")
        )

        response_text = f"""
‚è∞ **SELECCIONA TU CRONOGRAMA DE COCCI√ìN**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
‚ö° **Available Energy:** {user_profile['energy_data']['available_energy']} kcal/kg FFM/d√≠a

**OPCIONES DISPONIBLES:**

üéØ **Sesi√≥n √∫nica** - Un d√≠a, m√°xima eficiencia (4-6h)
‚öñÔ∏è **Dos sesiones** - Balance entre eficiencia y frescura
üîÑ **Tres sesiones** - M√°xima frescura distribuida
üìÖ **Preparaci√≥n diaria** - Sin meal prep, siempre fresco

**Selecciona la opci√≥n que mejor se adapte a tu Available Energy y horarios:**

**¬øQuieres m√°s opciones?**
Usa /nueva_semana para explorar cronogramas espec√≠ficos.
"""
        bot.send_message(
            message.chat.id, 
            response_text, 
            parse_mode='Markdown',
            reply_markup=keyboard
        )
        return
    
    response_text = f"""
‚è∞ **CRONOGRAMA DE COCCI√ìN SEMANAL**

üéØ **Tu cronograma:** {schedule_data.get('name', 'Personalizado')}
üìù **Descripci√≥n:** {schedule_data.get('description', 'Cronograma optimizado')}
‚è±Ô∏è **Tiempo estimado:** {schedule_data.get('estimated_time', 'Variable')}

**SESIONES PLANIFICADAS:**
"""
    
    sessions = schedule_data.get('sessions', [])
    for i, session in enumerate(sessions, 1):
        day = session.get('day', 'd√≠a').title()
        duration = session.get('duration', '2-3 horas')
        start_time = session.get('start_time', '10:00')
        tasks = session.get('tasks', [])
        
        response_text += f"""
**SESI√ìN {i} - {day}**
üïê Horario: {start_time}
‚è∞ Duraci√≥n: {duration}
üìã Tareas:
"""
        for task in tasks:
            response_text += f"‚Ä¢ {task.replace('_', ' ').title()}\n"
    
    # Ventajas/desventajas
    pros = schedule_data.get('pros', [])
    cons = schedule_data.get('cons', [])
    
    if pros:
        response_text += "\n‚úÖ **VENTAJAS:**\n"
        for pro in pros:
            response_text += f"‚Ä¢ {pro}\n"
    
    if cons:
        response_text += "\n‚ö†Ô∏è **CONSIDERACIONES:**\n"
        for con in cons:
            response_text += f"‚Ä¢ {con}\n"
    
    response_text += f"""

üí° **OPTIMIZACI√ìN SEG√öN TU PERFIL:**
‚Ä¢ Objetivo: {user_profile['basic_data']['objetivo_descripcion']}
‚Ä¢ Available Energy: {user_profile['energy_data']['available_energy']} kcal/kg FFM/d√≠a
‚Ä¢ Macros diarios: {user_profile['macros']['calories']} kcal

**¬øQuieres cambiar tu cronograma?**
Usa /nueva_semana para explorar otras opciones.
"""
    
    meal_bot.send_long_message(message.chat.id, response_text, parse_mode='Markdown')

@bot.message_handler(commands=['timing'])
def timing_command(message):
    """Mostrar timing nutricional personalizado seg√∫n horario de entrenamiento"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    if not user_profile:
        bot.send_message(message.chat.id, "‚ùå Error: No se pudo encontrar tu perfil")
        return
    
    exercise_profile = user_profile.get("exercise_profile", {})
    training_schedule = exercise_profile.get("training_schedule", "variable")
    training_desc = exercise_profile.get("training_schedule_desc", "Variable/Cambia")
    dynamic_timing = exercise_profile.get("dynamic_meal_timing", {})
    timing_desc = exercise_profile.get("timing_description", {})
    objetivo = user_profile["basic_data"]["objetivo_descripcion"]
    
    response_text = f"""
‚è∞ **TU TIMING NUTRICIONAL PERSONALIZADO**

üéØ **Horario de entrenamiento:** {training_desc}
üí™ **Objetivo:** {objetivo}

**DISTRIBUCI√ìN √ìPTIMA DE COMIDAS:**
"""
    
    # Iconos para cada comida
    meal_icons = {
        "desayuno": "üåÖ",
        "almuerzo": "üåû", 
        "merienda": "üåá",
        "cena": "üåô"
    }
    
    # Traducir categor√≠as de timing
    timing_translation = {
        "pre_entreno": "‚ö° PRE-ENTRENO",
        "post_entreno": "üí™ POST-ENTRENO",
        "comida_principal": "üçΩÔ∏è COMIDA PRINCIPAL", 
        "snack_complemento": "ü•ú SNACK/COMPLEMENTO"
    }
    
    for meal, timing_category in dynamic_timing.items():
        icon = meal_icons.get(meal, "üçΩÔ∏è")
        timing_name = timing_translation.get(timing_category, timing_category.title())
        response_text += f"\n{icon} **{meal.title()}:** {timing_name}"
    
    if timing_desc:
        response_text += f"""

üìù **ESTRATEGIA NUTRICIONAL:**
‚Ä¢ **Pre-entreno:** {timing_desc.get('pre_timing', 'Adaptado a tu horario')}
‚Ä¢ **Post-entreno:** {timing_desc.get('post_timing', 'Recuperaci√≥n optimizada')}
‚Ä¢ **Filosof√≠a:** {timing_desc.get('strategy', 'Personalizado seg√∫n tus necesidades')}

üí° **C√ìMO USARLO:**
‚Ä¢ Usa /generar y selecciona el timing de tu pr√≥xima comida
‚Ä¢ Las recetas se adaptar√°n autom√°ticamente a tu horario
‚Ä¢ /recetas te mostrar√° tus recetas organizadas por timing

üîÑ **¬øCambi√≥ tu horario?**
Usa /perfil para actualizar tu horario de entrenamiento.
"""
    else:
        response_text += """

üí° **C√ìMO USARLO:**
‚Ä¢ Usa /generar para crear recetas espec√≠ficas por timing
‚Ä¢ /recetas te mostrar√° todas tus recetas generadas
‚Ä¢ Cada receta est√° optimizada para el momento del d√≠a

üîÑ **¬øQuieres optimizar m√°s?**
Usa /perfil para configurar tu horario de entrenamiento espec√≠fico.
"""
    
    meal_bot.send_long_message(message.chat.id, response_text, parse_mode='Markdown')

@bot.message_handler(commands=['rating'])
def rating_command(message):
    """Comando para calificar recetas (placeholder)"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    # Extraer rating del mensaje (formato: /rating receta 1-5 comentario)
    text_parts = message.text.split(' ', 3)
    
    if len(text_parts) < 3:
        bot.send_message(
            message.chat.id,
            "üìä **SISTEMA DE CALIFICACIONES**\n\n"
            "**Uso:** `/rating nombre_receta 1-5 [comentario]`\n\n"
            "**Ejemplos:**\n"
            "‚Ä¢ `/rating pollo_quinoa 5 Excelente sabor`\n"
            "‚Ä¢ `/rating lentejas_curry 3 Muy salado`\n"
            "‚Ä¢ `/rating batido_proteina 4`\n\n"
            "**Tu feedback ayuda a mejorar las recetas futuras con IA.**",
            parse_mode='Markdown'
        )
        return
    
    recipe_name = text_parts[1]
    try:
        rating_value = int(text_parts[2])
        if not (1 <= rating_value <= 5):
            raise ValueError
    except (ValueError, IndexError):
        bot.send_message(
            message.chat.id,
            "‚ùå **Error:** La calificaci√≥n debe ser un n√∫mero del 1 al 5."
        )
        return
    
    comment = text_parts[3] if len(text_parts) > 3 else ""
    
    # Simular guardado de rating (se implementar√≠a completamente)
    bot.send_message(
        message.chat.id,
        f"‚≠ê **CALIFICACI√ìN GUARDADA**\n\n"
        f"**Receta:** {recipe_name.replace('_', ' ').title()}\n"
        f"**Puntuaci√≥n:** {rating_value}/5 {'‚≠ê' * rating_value}\n"
        f"**Comentario:** {comment if comment else 'Sin comentario'}\n\n"
        "‚úÖ Tu feedback se usar√° para mejorar futuras recomendaciones con IA.\n\n"
        "üí° **Tip:** Las recetas mejor calificadas aparecer√°n m√°s frecuentemente.",
        parse_mode='Markdown'
    )

@bot.message_handler(commands=['favorito'])
def favorito_command(message):
    """Comando para marcar recetas como favoritas (placeholder)"""
    telegram_id = str(message.from_user.id)
    
    if not meal_bot.create_user_if_not_exists(telegram_id, message):
        return
    
    # Extraer nombre de receta
    text_parts = message.text.split(' ', 1)
    
    if len(text_parts) < 2:
        bot.send_message(
            message.chat.id,
            "‚ù§Ô∏è **SISTEMA DE FAVORITOS**\n\n"
            "**Uso:** `/favorito nombre_receta`\n\n"
            "**Ejemplos:**\n"
            "‚Ä¢ `/favorito pollo_mediteraneo`\n"
            "‚Ä¢ `/favorito garbanzos_curry`\n"
            "‚Ä¢ `/favorito batido_recovery`\n\n"
            "**Las recetas favoritas tendr√°n prioridad en tus men√∫s semanales.**",
            parse_mode='Markdown'
        )
        return
    
    recipe_name = text_parts[1]
    
    # Simular guardado de favorito
    bot.send_message(
        message.chat.id,
        f"‚ù§Ô∏è **RECETA MARCADA COMO FAVORITA**\n\n"
        f"**Receta:** {recipe_name.replace('_', ' ').title()}\n\n"
        "‚úÖ Esta receta aparecer√° m√°s frecuentemente en tus men√∫s semanales.\n"
        "ü§ñ La IA tendr√° esto en cuenta para futuras recomendaciones.\n\n"
        "**Ver todos tus favoritos:** Pr√≥ximamente con /mis_favoritos",
        parse_mode='Markdown'
    )

# ========================================
# PROCESADORES DE ESTADO
# ========================================

def process_profile_setup(telegram_id: str, message):
    """Procesar configuraci√≥n de perfil paso a paso"""
    user_state = meal_bot.user_states.get(telegram_id, {})
    step = user_state.get("step", "peso")
    data = user_state.get("data", {})
    
    try:
        if step == "enfoque_dietetico":
            # Este paso se maneja por callbacks, no por texto
            bot.send_message(
                message.chat.id,
                "‚ö†Ô∏è Por favor, selecciona tu enfoque diet√©tico usando los botones de arriba.\n\n"
                "Si no los ves, usa `/perfil` para empezar de nuevo.",
                parse_mode='Markdown'
            )
            return
            
        elif step == "peso":
            peso = float(message.text)
            if not (30 <= peso <= 300):
                raise ValueError("Peso fuera de rango v√°lido")
            
            data["peso"] = peso
            meal_bot.user_states[telegram_id]["step"] = "altura"
            meal_bot.user_states[telegram_id]["data"] = data
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Peso registrado: {peso} kg\n\n"
                "üìè **Paso 2/10:** ¬øCu√°l es tu altura en cm?\n"
                "_(Ejemplo: 175)_"
            )
            
        elif step == "altura":
            altura = float(message.text)
            if not (120 <= altura <= 220):
                raise ValueError("Altura fuera de rango v√°lido")
            
            data["altura"] = altura
            meal_bot.user_states[telegram_id]["step"] = "edad"
            meal_bot.user_states[telegram_id]["data"] = data
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Altura registrada: {altura} cm\n\n"
                "üéÇ **Paso 3/10:** ¬øCu√°l es tu edad en a√±os?\n"
                "_(Ejemplo: 25)_"
            )
            
        elif step == "edad":
            edad = int(message.text)
            if not (15 <= edad <= 100):
                raise ValueError("Edad fuera de rango v√°lido")
            
            data["edad"] = edad
            meal_bot.user_states[telegram_id]["step"] = "sexo"
            meal_bot.user_states[telegram_id]["data"] = data
            
            keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
            keyboard.add("Masculino", "Femenino")
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Edad registrada: {edad} a√±os\n\n"
                "‚ößÔ∏è **Paso 4/10:** ¬øCu√°l es tu sexo biol√≥gico?\n"
                "_(Necesario para c√°lculos de BMR precisos)_",
                reply_markup=keyboard
            )
            
        elif step == "sexo":
            sexo = message.text.lower()
            if sexo not in ["masculino", "femenino"]:
                raise ValueError("Sexo debe ser Masculino o Femenino")
            
            data["sexo"] = sexo
            meal_bot.user_states[telegram_id]["step"] = "objetivo"
            meal_bot.user_states[telegram_id]["data"] = data
            
            keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
            keyboard.add("Bajar peso", "Ganar m√∫sculo")
            keyboard.add("Ganancia limpia", "Recomposici√≥n")
            keyboard.add("Mantener")
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Sexo registrado: {sexo}\n\n"
                "üéØ **Paso 5/10:** ¬øCu√°l es tu objetivo principal?\n\n"
                "**Bajar peso:** Perder grasa manteniendo m√∫sculo\n"
                "**Ganar m√∫sculo:** Super√°vit controlado (200-300 kcal)\n"
                "**Ganancia limpia:** Ultra-limpia (150-250 kcal super√°vit)\n"
                "**Recomposici√≥n:** Bajar grasa y ganar m√∫sculo simult√°neamente\n"
                "**Mantener:** Mantener peso y composici√≥n actual",
                reply_markup=keyboard
            )
            
        elif step == "objetivo":
            objetivos_map = {
                "bajar peso": "bajar_peso",
                "ganar m√∫sculo": "subir_masa", 
                "ganar musculo": "subir_masa",
                "ganancia limpia": "subir_masa_lean",
                "recomposici√≥n": "recomposicion",
                "recomposicion": "recomposicion",
                "mantener": "mantener"
            }
            
            objetivo = objetivos_map.get(message.text.lower())
            if not objetivo:
                raise ValueError("Objetivo no v√°lido")
            
            data["objetivo"] = objetivo
            meal_bot.user_states[telegram_id]["step"] = "actividad"
            meal_bot.user_states[telegram_id]["data"] = data
            
            keyboard = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
            keyboard.add("üè† Sedentario (0 d√≠as/semana)")
            keyboard.add("üö∂ Ligero (1-2 d√≠as/semana)")
            keyboard.add("üèÉ Moderado (3-4 d√≠as/semana)")
            keyboard.add("üí™ Intenso (5+ d√≠as/semana)")
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Objetivo registrado: {message.text}\n\n"
                "üèÉ **Paso 6/9:** ¬øCu√°l es tu nivel de actividad f√≠sica?\n\n"
                "Selecciona la opci√≥n que mejor describa tu rutina actual:\n\n"
                "üè† **Sedentario (0 d√≠as/semana)**\n"
                "   Trabajo de oficina, sin ejercicio regular\n\n"
                "üö∂ **Ligero (1-2 d√≠as/semana)**\n"
                "   Ejercicio ocasional, caminatas, actividad ligera\n\n"
                "üèÉ **Moderado (3-4 d√≠as/semana)**\n"
                "   Ejercicio regular, rutina establecida\n\n"
                "üí™ **Intenso (5+ d√≠as/semana)**\n"
                "   Ejercicio frecuente, alta dedicaci√≥n al fitness",
                reply_markup=keyboard
            )
            
        elif step == "actividad":
            # Procesar respuesta h√≠brida de actividad f√≠sica
            text = message.text.lower()
            
            if "sedentario" in text or "0 d√≠as" in text:
                activity_factor = 1.2
                frecuencia_semanal = 0
                activity_level = "sedentario"
            elif "ligero" in text or "1-2 d√≠as" in text:
                activity_factor = 1.375
                frecuencia_semanal = 1.5
                activity_level = "ligero"
            elif "moderado" in text or "3-4 d√≠as" in text:
                activity_factor = 1.55
                frecuencia_semanal = 3.5
                activity_level = "moderado"
            elif "intenso" in text or "5+" in text:
                activity_factor = 1.725
                frecuencia_semanal = 5.5
                activity_level = "intenso"
            else:
                raise ValueError("Nivel de actividad no v√°lido")
            
            data["activity_factor"] = activity_factor
            data["frecuencia_semanal"] = frecuencia_semanal
            data["activity_level"] = activity_level
            
            # Si es sedentario, saltar directamente a preferencias
            if activity_level == "sedentario":
                data["ejercicio_tipo"] = "ninguno"
                data["duracion_promedio"] = 0
                meal_bot.user_states[telegram_id]["step"] = "preferencias"
                meal_bot.user_states[telegram_id]["data"] = data
                
                keyboard = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
                keyboard.add("Continuar con preferencias")
                
                bot.send_message(
                    message.chat.id,
                    f"‚úÖ Actividad registrada: {activity_level.title()} (0 d√≠as/semana)\n\n"
                    "‚è≠Ô∏è **Saltando configuraci√≥n de ejercicio**\n\n"
                    "üçΩÔ∏è **Paso 7/9:** Configuremos tus preferencias alimentarias.\n"
                    "Presiona el bot√≥n para continuar.",
                    reply_markup=keyboard
                )
            else:
                meal_bot.user_states[telegram_id]["step"] = "ejercicio_tipo"
                meal_bot.user_states[telegram_id]["data"] = data
                
                keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
                keyboard.add("Fuerza/Pesas", "Cardio")
                keyboard.add("Deportes", "HIIT")
                keyboard.add("Mixto")
                
                bot.send_message(
                    message.chat.id,
                    f"‚úÖ Actividad registrada: {activity_level.title()} ({frecuencia_semanal} d√≠as/semana)\n\n"
                    "üèãÔ∏è **Paso 7/9:** ¬øQu√© tipo de ejercicio haces principalmente?\n\n"
                    "**Fuerza/Pesas:** Entrenamiento con resistencias\n"
                    "**Cardio:** Running, ciclismo, nataci√≥n\n"
                    "**Deportes:** F√∫tbol, tenis, baloncesto\n"
                    "**HIIT:** Entrenamientos de alta intensidad\n"
                    "**Mixto:** Combinaci√≥n de varios tipos",
                    reply_markup=keyboard
                )
            
        elif step == "ejercicio_tipo":
            tipos_ejercicio = {
                "fuerza/pesas": "fuerza",
                "cardio": "cardio", 
                "deportes": "deportes",
                "hiit": "hiit",
                "mixto": "mixto"
            }
            
            tipo_ejercicio = tipos_ejercicio.get(message.text.lower())
            if not tipo_ejercicio:
                raise ValueError("Tipo de ejercicio no v√°lido")
            
            data["ejercicio_tipo"] = tipo_ejercicio
            meal_bot.user_states[telegram_id]["step"] = "duracion"
            meal_bot.user_states[telegram_id]["data"] = data
            
            keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
            keyboard.add("30-45 min", "45-60 min")
            keyboard.add("60-90 min", "90+ min")
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Ejercicio registrado: {message.text}\n\n"
                "‚è±Ô∏è **Paso 8/9:** ¬øCu√°nto dura cada sesi√≥n de entrenamiento?\n\n"
                "Tiempo promedio por sesi√≥n incluyendo calentamiento.",
                reply_markup=keyboard
            )
            
        elif step == "duracion":
            # Procesamiento flexible de duraci√≥n
            text = message.text.lower().strip()
            
            # Extraer n√∫meros del texto
            import re
            numbers = re.findall(r'\d+', text)
            
            if numbers:
                # Usar el primer n√∫mero encontrado como referencia
                duration_num = int(numbers[0])
                
                if duration_num <= 30:
                    duracion = 30
                elif duration_num <= 45:
                    duracion = 37.5
                elif duration_num <= 60:
                    duracion = 52.5
                elif duration_num <= 90:
                    duracion = 75
                else:
                    duracion = 105
            elif any(keyword in text for keyword in ["30", "45", "corta", "rapida"]):
                duracion = 37.5
            elif any(keyword in text for keyword in ["60", "hora", "normal"]):
                duracion = 52.5
            elif any(keyword in text for keyword in ["90", "larga", "intensa"]):
                duracion = 75
            else:
                bot.send_message(
                    message.chat.id,
                    "‚ùå **No pude entender la duraci√≥n.**\n\n"
                    "Por favor, usa los botones del teclado o escribe un tiempo como:\n"
                    "‚Ä¢ **30-45 minutos**\n"
                    "‚Ä¢ **60 minutos**\n"
                    "‚Ä¢ **90 minutos**"
                )
                return
            
            data["duracion_promedio"] = duracion
            meal_bot.user_states[telegram_id]["data"] = data
            
            # Ir a horario de entrenamiento
            meal_bot.user_states[telegram_id]["step"] = "horario_entrenamiento"
            
            keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
            keyboard.add("üåÖ Ma√±ana (6:00-12:00)", "üåû Mediod√≠a (12:00-16:00)")
            keyboard.add("üåá Tarde (16:00-20:00)", "üåô Noche (20:00-24:00)")
            keyboard.add("üîÑ Variable/Cambia")
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Duraci√≥n registrada: {message.text}\n\n"
                "‚è∞ **Paso 9/9:** ¬øA qu√© hora entrenas normalmente?\n\n"
                "**Esto nos ayuda a optimizar tu timing nutricional:**\n"
                "‚Ä¢ Pre-entreno: 30-60 min antes\n"
                "‚Ä¢ Post-entreno: inmediatamente despu√©s\n"
                "‚Ä¢ Comidas principales: horarios que no interfieran\n\n"
                "**Selecciona tu horario habitual:**",
                reply_markup=keyboard
            )
            
        elif step == "horario_entrenamiento":
            # Procesar horario de entrenamiento
            text = message.text.lower().strip()
            
            # Mapear texto a valores estructurados
            if "ma√±ana" in text or "6:00-12:00" in text:
                horario = "ma√±ana"
                horario_desc = "Ma√±ana (6:00-12:00)"
            elif "mediod√≠a" in text or "mediodia" in text or "12:00-16:00" in text:
                horario = "mediodia" 
                horario_desc = "Mediod√≠a (12:00-16:00)"
            elif "tarde" in text or "16:00-20:00" in text:
                horario = "tarde"
                horario_desc = "Tarde (16:00-20:00)"
            elif "noche" in text or "20:00-24:00" in text:
                horario = "noche"
                horario_desc = "Noche (20:00-24:00)"
            elif "variable" in text or "cambia" in text:
                horario = "variable"
                horario_desc = "Variable/Cambia"
            else:
                bot.send_message(
                    message.chat.id,
                    "‚ùå **No reconoc√≠ ese horario.**\n\n"
                    "Por favor usa los botones o escribe: ma√±ana, mediod√≠a, tarde, noche, o variable."
                )
                return
            
            data["horario_entrenamiento"] = horario
            data["horario_entrenamiento_desc"] = horario_desc
            meal_bot.user_states[telegram_id]["data"] = data
            
            # Ir a preferencias de prote√≠nas
            meal_bot.user_states[telegram_id]["step"] = "gustos_proteinas"
            
            # Inicializar lista de prote√≠nas vac√≠a
            data["liked_proteins"] = []
            
            keyboard = types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True)
            keyboard.add("üçó Pollo", "ü•© Ternera", "üêü Pescado")
            keyboard.add("ü•ö Huevos", "ü´ò Legumbres", "üßÄ L√°cteos") 
            keyboard.add("üå∞ Frutos secos", "‚úÖ Todas", "‚è≠Ô∏è Ninguna especial")
            keyboard.add("‚û°Ô∏è Continuar")
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Horario registrado: {horario_desc}\n\n"
                "üçΩÔ∏è **CONFIGURACI√ìN FINAL:** ¬øQu√© PROTE√çNAS prefieres?\n\n"
                "**Opciones disponibles:**\n"
                "‚Ä¢ üçó Pollo\n"
                "‚Ä¢ ü•© Ternera  \n"
                "‚Ä¢ üêü Pescado\n"
                "‚Ä¢ ü•ö Huevos\n"
                "‚Ä¢ ü´ò Legumbres\n"
                "‚Ä¢ üßÄ L√°cteos\n"
                "‚Ä¢ üå∞ Frutos secos\n"
                "‚Ä¢ ‚úÖ Todas\n"
                "‚Ä¢ ‚è≠Ô∏è Ninguna especial\n\n"
                "**PUEDES SELECCIONAR M√öLTIPLES OPCIONES**\n"
                "Usa ‚û°Ô∏è **Continuar** cuando termines de seleccionar:",
                reply_markup=keyboard
            )
            
        elif step == "gustos_proteinas":
            # Procesar selecci√≥n m√∫ltiple de prote√≠nas
            text = message.text.lower().strip()
            
            # Inicializar lista si no existe
            if "liked_proteins" not in data:
                data["liked_proteins"] = []
            
            # Verificar si quiere continuar
            if "continuar" in text or text == "‚û°Ô∏è continuar":
                # Continuar al siguiente paso
                pass
            elif "ninguna" in text or text == "‚è≠Ô∏è ninguna especial":
                data["liked_proteins"] = []
            elif "todas" in text or text == "‚úÖ todas":
                data["liked_proteins"] = ["pollo", "ternera", "pescado", "huevos", "legumbres", "lacteos", "frutos_secos"]
            else:
                # Mapear tanto emojis como texto
                protein_map = {
                    "üçó pollo": "pollo", "pollo": "pollo",
                    "ü•© ternera": "ternera", "ternera": "ternera", "carne": "ternera",
                    "üêü pescado": "pescado", "pescado": "pescado", "pez": "pescado",
                    "ü•ö huevos": "huevos", "huevos": "huevos", "huevo": "huevos",
                    "ü´ò legumbres": "legumbres", "legumbres": "legumbres", "lentejas": "legumbres",
                    "üßÄ l√°cteos": "lacteos", "lacteos": "lacteos", "queso": "lacteos", "yogur": "lacteos",
                    "üå∞ frutos secos": "frutos_secos", "frutos secos": "frutos_secos", "nueces": "frutos_secos"
                }
                
                selected = None
                for key, value in protein_map.items():
                    if key in text or text in key:
                        selected = value
                        break
                
                if selected:
                    # Agregar a la lista si no est√° ya incluido
                    if selected not in data["liked_proteins"]:
                        data["liked_proteins"].append(selected)
                        
                    # Mostrar selecci√≥n actual y continuar
                    selected_names = [name.replace("_", " ").title() for name in data["liked_proteins"]]
                    selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
                    
                    bot.send_message(
                        message.chat.id,
                        f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido\n\n"
                        f"**Seleccionados:** {selection_text}\n\n"
                        "Puedes seleccionar m√°s opciones o usar ‚û°Ô∏è **Continuar**"
                    )
                    return  # Mantener en el mismo paso
                else:
                    # Si no reconoce la entrada, pedir clarificaci√≥n
                    bot.send_message(
                        message.chat.id,
                        "‚ùå No reconoc√≠ esa opci√≥n. Por favor usa los botones o escribe: pollo, ternera, pescado, huevos, legumbres, lacteos, frutos secos, todas, ninguna, o continuar."
                    )
                    return
            
            meal_bot.user_states[telegram_id]["step"] = "gustos_carbos"
            meal_bot.user_states[telegram_id]["data"] = data
            
            # Inicializar lista de carbohidratos
            data["liked_carbs"] = []
            
            keyboard = types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True)
            keyboard.add("üçö Arroz", "üåæ Quinoa", "üçû Avena")
            keyboard.add("ü•î Patatas", "üçù Pasta", "ü´ì Pan integral")
            keyboard.add("üçå Frutas", "‚úÖ Todas", "‚è≠Ô∏è Ninguna especial")
            keyboard.add("‚û°Ô∏è Continuar")
            
            selected_proteins = [name.replace("_", " ").title() for name in data["liked_proteins"]]
            protein_text = ", ".join(selected_proteins) if selected_proteins else "Ninguna"
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Prote√≠nas registradas: {protein_text}\n\n"
                "üçΩÔ∏è **Paso 9B/10:** ¬øQu√© CARBOHIDRATOS prefieres?\n\n"
                "**Opciones disponibles:**\n"
                "‚Ä¢ üçö Arroz\n"
                "‚Ä¢ üåæ Quinoa\n"
                "‚Ä¢ üçû Avena\n"
                "‚Ä¢ ü•î Patatas\n"
                "‚Ä¢ üçù Pasta\n"
                "‚Ä¢ ü´ì Pan integral\n"
                "‚Ä¢ üçå Frutas\n"
                "‚Ä¢ ‚úÖ Todas\n"
                "‚Ä¢ ‚è≠Ô∏è Ninguna especial\n\n"
                "**PUEDES SELECCIONAR M√öLTIPLES OPCIONES**\n"
                "Usa ‚û°Ô∏è **Continuar** cuando termines de seleccionar:",
                reply_markup=keyboard
            )
            
        elif step == "gustos_carbos":
            # Procesar selecci√≥n m√∫ltiple de carbohidratos
            text = message.text.lower().strip()
            
            # Inicializar lista si no existe
            if "liked_carbs" not in data:
                data["liked_carbs"] = []
            
            # Verificar si quiere continuar
            if "continuar" in text or text == "‚û°Ô∏è continuar":
                # Continuar al siguiente paso
                pass
            elif "ninguna" in text or text == "‚è≠Ô∏è ninguna especial":
                data["liked_carbs"] = []
            elif "todas" in text or text == "‚úÖ todas":
                data["liked_carbs"] = ["arroz", "quinoa", "avena", "patatas", "pasta", "pan_integral", "frutas"]
            else:
                carb_map = {
                    "üçö arroz": "arroz", "arroz": "arroz",
                    "üåæ quinoa": "quinoa", "quinoa": "quinoa",
                    "üçû avena": "avena", "avena": "avena",
                    "ü•î patatas": "patatas", "patatas": "patatas", "papa": "patatas",
                    "üçù pasta": "pasta", "pasta": "pasta",
                    "ü´ì pan integral": "pan_integral", "pan integral": "pan_integral", "pan": "pan_integral",
                    "üçå frutas": "frutas", "frutas": "frutas", "fruta": "frutas"
                }
                
                selected = None
                for key, value in carb_map.items():
                    if key in text or text in key:
                        selected = value
                        break
                
                if selected:
                    # Agregar a la lista si no est√° ya incluido
                    if selected not in data["liked_carbs"]:
                        data["liked_carbs"].append(selected)
                        
                    # Mostrar selecci√≥n actual y continuar
                    selected_names = [name.replace("_", " ").title() for name in data["liked_carbs"]]
                    selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
                    
                    bot.send_message(
                        message.chat.id,
                        f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido\n\n"
                        f"**Seleccionados:** {selection_text}\n\n"
                        "Puedes seleccionar m√°s opciones o usar ‚û°Ô∏è **Continuar**"
                    )
                    return  # Mantener en el mismo paso
                else:
                    bot.send_message(
                        message.chat.id,
                        "‚ùå No reconoc√≠ esa opci√≥n. Por favor usa los botones o escribe: arroz, quinoa, avena, patatas, pasta, pan integral, frutas, todas, ninguna, o continuar."
                    )
                    return
            
            meal_bot.user_states[telegram_id]["step"] = "gustos_verduras"
            meal_bot.user_states[telegram_id]["data"] = data
            
            # Inicializar lista de verduras
            data["liked_vegetables"] = []
            
            keyboard = types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True)
            keyboard.add("ü•¨ Hojas verdes", "ü•¶ Cruc√≠feras", "üçÖ Solan√°ceas")
            keyboard.add("üßÑ Arom√°ticas", "ü•ï Ra√≠ces", "ü´ë Pimientos")
            keyboard.add("ü•í Pepin√°ceas", "‚úÖ Todas", "‚è≠Ô∏è Ninguna especial")
            keyboard.add("‚û°Ô∏è Continuar")
            
            selected_carbs = [name.replace("_", " ").title() for name in data["liked_carbs"]]
            carb_text = ", ".join(selected_carbs) if selected_carbs else "Ninguna"
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Carbohidratos registrados: {carb_text}\n\n"
                "üçΩÔ∏è **Paso 9C/10:** ¬øQu√© VERDURAS prefieres?\n\n"
                "**Familias de vegetales disponibles:**\n"
                "‚Ä¢ ü•¨ Hojas verdes\n"
                "‚Ä¢ ü•¶ Cruc√≠feras\n"
                "‚Ä¢ üçÖ Solan√°ceas\n"
                "‚Ä¢ üßÑ Arom√°ticas\n"
                "‚Ä¢ ü•ï Ra√≠ces\n"
                "‚Ä¢ ü´ë Pimientos\n"
                "‚Ä¢ ü•í Pepin√°ceas\n"
                "‚Ä¢ ‚úÖ Todas\n"
                "‚Ä¢ ‚è≠Ô∏è Ninguna especial\n\n"
                "**PUEDES SELECCIONAR M√öLTIPLES OPCIONES**\n"
                "Usa ‚û°Ô∏è **Continuar** cuando termines de seleccionar:",
                reply_markup=keyboard
            )
            
        elif step == "gustos_verduras":
            # Procesar selecci√≥n m√∫ltiple de verduras
            text = message.text.lower().strip()
            
            # Inicializar lista si no existe
            if "liked_vegetables" not in data:
                data["liked_vegetables"] = []
            
            # Verificar si quiere continuar
            if "continuar" in text or text == "‚û°Ô∏è continuar":
                # Continuar al siguiente paso
                pass
            elif "ninguna" in text or text == "‚è≠Ô∏è ninguna especial":
                data["liked_vegetables"] = []
            elif "todas" in text or text == "‚úÖ todas":
                data["liked_vegetables"] = ["hojas_verdes", "cruciferas", "solanaceas", "aromaticas", "raices", "pimientos", "pepinaceas"]
            else:
                veg_map = {
                    "ü•¨ hojas verdes": "hojas_verdes", "hojas verdes": "hojas_verdes", "espinaca": "hojas_verdes", "lechuga": "hojas_verdes",
                    "ü•¶ cruc√≠feras": "cruciferas", "cruciferas": "cruciferas", "brocoli": "cruciferas", "coliflor": "cruciferas",
                    "üçÖ solan√°ceas": "solanaceas", "solanaceas": "solanaceas", "tomate": "solanaceas", "berenjena": "solanaceas",
                    "üßÑ arom√°ticas": "aromaticas", "aromaticas": "aromaticas", "ajo": "aromaticas", "cebolla": "aromaticas",
                    "ü•ï ra√≠ces": "raices", "raices": "raices", "zanahoria": "raices", "remolacha": "raices",
                    "ü´ë pimientos": "pimientos", "pimientos": "pimientos", "pimiento": "pimientos",
                    "ü•í pepin√°ceas": "pepinaceas", "pepinaceas": "pepinaceas", "pepino": "pepinaceas", "calabacin": "pepinaceas"
                }
                
                selected = None
                for key, value in veg_map.items():
                    if key in text or text in key:
                        selected = value
                        break
                
                if selected:
                    # Agregar a la lista si no est√° ya incluido
                    if selected not in data["liked_vegetables"]:
                        data["liked_vegetables"].append(selected)
                        
                    # Mostrar selecci√≥n actual y continuar
                    selected_names = [name.replace("_", " ").title() for name in data["liked_vegetables"]]
                    selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
                    
                    bot.send_message(
                        message.chat.id,
                        f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido\n\n"
                        f"**Seleccionados:** {selection_text}\n\n"
                        "Puedes seleccionar m√°s opciones o usar ‚û°Ô∏è **Continuar**"
                    )
                    return  # Mantener en el mismo paso
                else:
                    bot.send_message(
                        message.chat.id,
                        "‚ùå No reconoc√≠ esa opci√≥n. Por favor usa los botones o escribe: hojas verdes, cruciferas, solanaceas, aromaticas, raices, pimientos, pepinaceas, todas, ninguna, o continuar."
                    )
                    return
            
            meal_bot.user_states[telegram_id]["step"] = "disgustos"
            meal_bot.user_states[telegram_id]["data"] = data
            
            # Inicializar lista de alimentos a evitar
            data["disliked_foods"] = []
            
            keyboard = types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True)
            keyboard.add("üêü Pescado", "ü•õ L√°cteos", "üå∂Ô∏è Picante")
            keyboard.add("üßÑ Ajo/Cebolla", "ü•ú Frutos secos", "üçÑ Hongos")
            keyboard.add("üåø Cilantro", "‚è≠Ô∏è Sin restricciones", "üìù Otros")
            keyboard.add("‚û°Ô∏è Continuar")
            
            selected_veggies = [name.replace("_", " ").title() for name in data["liked_vegetables"]]
            veggie_text = ", ".join(selected_veggies) if selected_veggies else "Ninguna"
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Verduras registradas: {veggie_text}\n\n"
                "üö´ **Paso 9D/10:** ¬øQu√© alimentos prefieres EVITAR?\n\n"
                "**Opciones disponibles:**\n"
                "‚Ä¢ üêü Pescado\n"
                "‚Ä¢ ü•õ L√°cteos\n"
                "‚Ä¢ üå∂Ô∏è Picante\n"
                "‚Ä¢ üßÑ Ajo/Cebolla\n"
                "‚Ä¢ ü•ú Frutos secos\n"
                "‚Ä¢ üçÑ Hongos\n"
                "‚Ä¢ üåø Cilantro\n"
                "‚Ä¢ ‚è≠Ô∏è Sin restricciones\n"
                "‚Ä¢ üìù Otros\n\n"
                "**PUEDES SELECCIONAR M√öLTIPLES OPCIONES**\n"
                "Usa ‚û°Ô∏è **Continuar** cuando termines de seleccionar:",
                reply_markup=keyboard
            )
            
            
        elif step == "disgustos":
            # Procesar selecci√≥n m√∫ltiple de alimentos a evitar
            text = message.text.lower().strip()
            
            # Inicializar lista si no existe
            if "disliked_foods" not in data:
                data["disliked_foods"] = []
            
            # Verificar si quiere continuar
            if "continuar" in text or text == "‚û°Ô∏è continuar":
                # Continuar al siguiente paso
                pass
            elif "sin restricciones" in text or "ninguna" in text:
                data["disliked_foods"] = []
            elif "otros" in text or text == "üìù otros":
                # Permitir texto libre para casos espec√≠ficos
                meal_bot.user_states[telegram_id]["step"] = "disgustos_texto"
                bot.send_message(
                    message.chat.id,
                    "üìù **Escribe otros alimentos que prefieres evitar:**\n\n"
                    "Ejemplos: mariscos, gluten, soja, c√≠tricos\n\n"
                    "Sep√°ralos por comas o escribe 'ninguno':"
                )
                return
            else:
                dislike_map = {
                    "üêü pescado": "pescado", "pescado": "pescado", "pez": "pescado",
                    "ü•õ l√°cteos": "lacteos", "lacteos": "lacteos", "leche": "lacteos", "queso": "lacteos",
                    "üå∂Ô∏è picante": "picante", "picante": "picante", "chile": "picante",
                    "üßÑ ajo/cebolla": "ajo_cebolla", "ajo": "ajo_cebolla", "cebolla": "ajo_cebolla",
                    "ü•ú frutos secos": "frutos_secos", "frutos secos": "frutos_secos", "nueces": "frutos_secos",
                    "üçÑ hongos": "hongos", "hongos": "hongos", "setas": "hongos",
                    "üåø cilantro": "cilantro", "cilantro": "cilantro"
                }
                
                selected = None
                for key, value in dislike_map.items():
                    if key in text or text in key:
                        selected = value
                        break
                
                if selected:
                    # Agregar a la lista si no est√° ya incluido
                    if selected not in data["disliked_foods"]:
                        data["disliked_foods"].append(selected)
                        
                    # Mostrar selecci√≥n actual y continuar
                    selected_names = [name.replace("_", " ").title() for name in data["disliked_foods"]]
                    selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
                    
                    bot.send_message(
                        message.chat.id,
                        f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido a evitar\n\n"
                        f"**A evitar:** {selection_text}\n\n"
                        "Puedes seleccionar m√°s opciones o usar ‚û°Ô∏è **Continuar**"
                    )
                    return  # Mantener en el mismo paso
                else:
                    bot.send_message(
                        message.chat.id,
                        "‚ùå No reconoc√≠ esa opci√≥n. Por favor usa los botones o escribe: pescado, lacteos, picante, ajo, cebolla, frutos secos, hongos, cilantro, sin restricciones, otros, o continuar."
                    )
                    return
            
            meal_bot.user_states[telegram_id]["step"] = "restricciones"
            meal_bot.user_states[telegram_id]["data"] = data
            
            # Inicializar lista de restricciones especiales
            data["special_restrictions"] = []
            
            keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
            keyboard.add("üö´ Alergias", "üå± Vegano")
            keyboard.add("ü•õ Sin lactosa", "üåæ Sin gluten")
            keyboard.add("üïå Halal", "‚ú°Ô∏è Kosher")
            keyboard.add("‚è≠Ô∏è Sin restricciones especiales")
            keyboard.add("‚û°Ô∏è Continuar")
            
            selected_dislikes = [name.replace("_", " ").title() for name in data["disliked_foods"]]
            dislike_text = ", ".join(selected_dislikes) if selected_dislikes else "Ninguna"
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Alimentos a evitar registrados: {dislike_text}\n\n"
                "‚ö†Ô∏è **Paso 9E/10:** ¬øTienes alguna RESTRICCI√ìN ESPECIAL?\n\n"
                "**Opciones disponibles:**\n"
                "‚Ä¢ üö´ Alergias\n"
                "‚Ä¢ üå± Vegano\n"
                "‚Ä¢ ü•õ Sin lactosa\n"
                "‚Ä¢ üåæ Sin gluten\n"
                "‚Ä¢ üïå Halal\n"
                "‚Ä¢ ‚ú°Ô∏è Kosher\n"
                "‚Ä¢ ‚è≠Ô∏è Sin restricciones especiales\n\n"
                "**PUEDES SELECCIONAR M√öLTIPLES OPCIONES**\n"
                "Usa ‚û°Ô∏è **Continuar** cuando termines de seleccionar:",
                reply_markup=keyboard
            )
            
        elif step == "disgustos_texto":
            # Procesar disgustos por texto libre
            if message.text.lower() in ["ninguno", "sin restricciones", "no"]:
                additional_dislikes = []
            else:
                additional_dislikes = [food.strip() for food in message.text.split(',')]
            
            # Combinar con restricciones anteriores
            current_dislikes = data.get("disliked_foods", [])
            data["disliked_foods"] = current_dislikes + additional_dislikes
            
            meal_bot.user_states[telegram_id]["step"] = "restricciones"
            meal_bot.user_states[telegram_id]["data"] = data
            
            keyboard = types.ReplyKeyboardMarkup(row_width=2, resize_keyboard=True)
            keyboard.add("üö´ Alergias", "üå± Vegano")
            keyboard.add("ü•õ Sin lactosa", "üåæ Sin gluten")
            keyboard.add("üïå Halal", "‚ú°Ô∏è Kosher")
            keyboard.add("‚è≠Ô∏è Sin restricciones especiales")
            
            bot.send_message(
                message.chat.id,
                "‚úÖ Alimentos adicionales registrados\n\n"
                "‚ö†Ô∏è **Paso 9E/10:** ¬øTienes alguna RESTRICCI√ìN ESPECIAL?\n\n"
                "**Opciones disponibles:**\n"
                "‚Ä¢ üö´ Alergias\n"
                "‚Ä¢ üå± Vegano\n"
                "‚Ä¢ ü•õ Sin lactosa\n"
                "‚Ä¢ üåæ Sin gluten\n"
                "‚Ä¢ üïå Halal\n"
                "‚Ä¢ ‚ú°Ô∏è Kosher\n"
                "‚Ä¢ ‚è≠Ô∏è Sin restricciones especiales\n\n"
                "Puedes usar los botones o escribir el nombre:",
                reply_markup=keyboard
            )
            
        elif step == "restricciones":
            # Procesar selecci√≥n m√∫ltiple de restricciones especiales
            text = message.text.lower().strip()
            
            # Inicializar lista si no existe
            if "special_restrictions" not in data:
                data["special_restrictions"] = []
            
            # Verificar si quiere continuar
            if "continuar" in text or text == "‚û°Ô∏è continuar":
                # Continuar al siguiente paso
                pass
            elif "sin restricciones" in text or "ninguna" in text:
                data["special_restrictions"] = []
            else:
                restriction_map = {
                    "üö´ alergias": "alergias", "alergias": "alergias", "alergia": "alergias",
                    "üå± vegano": "vegano", "vegano": "vegano", "vegetariano": "vegano",
                    "ü•õ sin lactosa": "sin_lactosa", "sin lactosa": "sin_lactosa", "lactosa": "sin_lactosa",
                    "üåæ sin gluten": "sin_gluten", "sin gluten": "sin_gluten", "gluten": "sin_gluten", "celiaco": "sin_gluten",
                    "üïå halal": "halal", "halal": "halal",
                    "‚ú°Ô∏è kosher": "kosher", "kosher": "kosher"
                }
                
                selected = None
                for key, value in restriction_map.items():
                    if key in text or text in key:
                        selected = value
                        break
                
                if selected:
                    # Agregar a la lista si no est√° ya incluido
                    if selected not in data["special_restrictions"]:
                        data["special_restrictions"].append(selected)
                        
                    # Mostrar selecci√≥n actual y continuar
                    selected_names = [name.replace("_", " ").title() for name in data["special_restrictions"]]
                    selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
                    
                    bot.send_message(
                        message.chat.id,
                        f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido\n\n"
                        f"**Restricciones:** {selection_text}\n\n"
                        "Puedes seleccionar m√°s opciones o usar ‚û°Ô∏è **Continuar**"
                    )
                    return  # Mantener en el mismo paso
                else:
                    bot.send_message(
                        message.chat.id,
                        "‚ùå No reconoc√≠ esa opci√≥n. Por favor usa los botones o escribe: alergias, vegano, sin lactosa, sin gluten, halal, kosher, sin restricciones, o continuar."
                    )
                    return
            
            meal_bot.user_states[telegram_id]["step"] = "metodos_coccion"
            meal_bot.user_states[telegram_id]["data"] = data
            
            # Inicializar lista de m√©todos de cocci√≥n
            data["cooking_methods"] = []
            
            keyboard = types.ReplyKeyboardMarkup(row_width=3, resize_keyboard=True)
            keyboard.add("üî• Horno", "üç≥ Sart√©n", "üç≤ Plancha")
            keyboard.add("ü•ò Guisos", "üçú Vapor", "ü•ó Crudo")
            keyboard.add("‚úÖ Todos", "‚è≠Ô∏è Sin preferencias")
            keyboard.add("‚û°Ô∏è Continuar")
            
            selected_restrictions = [name.replace("_", " ").title() for name in data["special_restrictions"]]
            restriction_text = ", ".join(selected_restrictions) if selected_restrictions else "Ninguna"
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ Restricciones registradas: {restriction_text}\n\n"
                "üë®‚Äçüç≥ **Paso 9F/10:** ¬øQu√© M√âTODOS DE COCCI√ìN prefieres?\n\n"
                "**Opciones disponibles:**\n"
                "‚Ä¢ üî• Horno\n"
                "‚Ä¢ üç≥ Sart√©n\n"
                "‚Ä¢ üç≤ Plancha\n"
                "‚Ä¢ ü•ò Guisos\n"
                "‚Ä¢ üçú Vapor\n"
                "‚Ä¢ ü•ó Crudo\n"
                "‚Ä¢ ‚úÖ Todos\n"
                "‚Ä¢ ‚è≠Ô∏è Sin preferencias\n\n"
                "**PUEDES SELECCIONAR M√öLTIPLES OPCIONES**\n"
                "Usa ‚û°Ô∏è **Continuar** cuando termines de seleccionar:",
                reply_markup=keyboard
            )
            
        elif step == "metodos_coccion":
            # Procesar selecci√≥n m√∫ltiple de m√©todos de cocci√≥n
            text = message.text.lower().strip()
            
            # Inicializar lista si no existe
            if "cooking_methods" not in data:
                data["cooking_methods"] = []
            
            # Verificar si quiere continuar
            if "continuar" in text or text == "‚û°Ô∏è continuar":
                # Si no ha seleccionado nada, usar valores por defecto
                if not data["cooking_methods"]:
                    data["cooking_methods"] = ["horno", "sarten", "plancha"]  # Default
            elif "sin preferencias" in text or "ninguna" in text:
                data["cooking_methods"] = ["horno", "sarten", "plancha"]  # Default
            elif "todos" in text or text == "‚úÖ todos":
                data["cooking_methods"] = ["horno", "sarten", "plancha", "guisos", "vapor", "crudo"]
            else:
                method_map = {
                    "üî• horno": "horno", "horno": "horno",
                    "üç≥ sart√©n": "sarten", "sarten": "sarten", "sart√©n": "sarten", "freir": "sarten",
                    "üç≤ plancha": "plancha", "plancha": "plancha", "grill": "plancha",
                    "ü•ò guisos": "guisos", "guisos": "guisos", "hervir": "guisos", "cocido": "guisos",
                    "üçú vapor": "vapor", "vapor": "vapor", "vaporera": "vapor",
                    "ü•ó crudo": "crudo", "crudo": "crudo", "ensalada": "crudo"
                }
                
                selected = None
                for key, value in method_map.items():
                    if key in text or text in key:
                        selected = value
                        break
                
                if selected:
                    # Agregar a la lista si no est√° ya incluido
                    if selected not in data["cooking_methods"]:
                        data["cooking_methods"].append(selected)
                        
                    # Mostrar selecci√≥n actual y continuar
                    selected_names = [name.replace("_", " ").title() for name in data["cooking_methods"]]
                    selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
                    
                    bot.send_message(
                        message.chat.id,
                        f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido\n\n"
                        f"**M√©todos seleccionados:** {selection_text}\n\n"
                        "Puedes seleccionar m√°s opciones o usar ‚û°Ô∏è **Continuar**"
                    )
                    return  # Mantener en el mismo paso
                else:
                    bot.send_message(
                        message.chat.id,
                        "‚ùå No reconoc√≠ esa opci√≥n. Por favor usa los botones o escribe: horno, sarten, plancha, guisos, vapor, crudo, todos, sin preferencias, o continuar."
                    )
                    return
            
            meal_bot.user_states[telegram_id]["step"] = "finalizar"
            meal_bot.user_states[telegram_id]["data"] = data
            
            keyboard = types.ReplyKeyboardMarkup(row_width=1, resize_keyboard=True)
            keyboard.add("‚úÖ Crear mi perfil nutricional")
            
            selected_methods = [name.replace("_", " ").title() for name in data["cooking_methods"]]
            methods_text = ", ".join(selected_methods) if selected_methods else "Por defecto"
            
            bot.send_message(
                message.chat.id,
                f"‚úÖ M√©todos de cocci√≥n registrados: {methods_text}\n\n"
                "üéØ **Paso 10/10:** ¬°Todo listo para crear tu perfil cient√≠fico!\n\n"
                "üìä **Tu configuraci√≥n incluye:**\n"
                "‚Ä¢ Datos biom√©tricos y objetivo\n"
                "‚Ä¢ Available Energy cient√≠fico\n"
                "‚Ä¢ Distribuci√≥n de ejercicio detallada\n"
                "‚Ä¢ Preferencias alimentarias completas\n"
                "‚Ä¢ Restricciones y m√©todos de cocci√≥n\n\n"
                "ü§ñ **El sistema generar√° recetas personalizadas con IA**\n\n"
                "**Para finalizar:**\n"
                "‚Ä¢ Usa el bot√≥n: ‚úÖ Crear mi perfil nutricional\n"
                "‚Ä¢ O escribe: 'crear perfil' o 'finalizar'\n\n"
                "¬°Tu perfil cient√≠fico estar√° listo en segundos!",
                reply_markup=keyboard
            )
            
        elif step == "finalizar":
            # Validar entrada flexible para crear perfil
            text = message.text.lower().strip()
            
            # Aceptar m√∫ltiples variaciones
            valid_inputs = [
                "‚úÖ crear mi perfil nutricional",
                "crear mi perfil nutricional", 
                "crear perfil",
                "crear",
                "finalizar",
                "terminar",
                "continuar",
                "listo",
                "si"
            ]
            
            # Verificar si la entrada es v√°lida
            is_valid = False
            for valid_input in valid_inputs:
                if valid_input in text or text in valid_input:
                    is_valid = True
                    break
            
            if not is_valid:
                bot.send_message(
                    message.chat.id,
                    "‚ùå Para crear tu perfil, por favor:\n\n"
                    "‚Ä¢ Usa el bot√≥n: ‚úÖ Crear mi perfil nutricional\n"
                    "‚Ä¢ O escribe: 'crear perfil', 'finalizar', 'listo'\n\n"
                    "¬°Est√°s a un paso de tener tu perfil cient√≠fico!"
                )
                return
            
            # Crear perfil completo usando UserProfileSystem
            try:
                # Preparar datos para el sistema de perfiles
                exercise_data = []
                if data.get("ejercicio_tipo", "ninguno") != "ninguno":
                    exercise_data = [{
                        "tipo": data["ejercicio_tipo"],
                        "subtipo": "intensidad_media",  # Default
                        "duracion": data["duracion_promedio"],
                        "peso": data["peso"],
                        "frecuencia_semanal": data["frecuencia_semanal"]
                    }]
                
                # Combinar todas las preferencias alimentarias
                all_liked_foods = (
                    data.get("liked_proteins", []) + 
                    data.get("liked_carbs", []) + 
                    data.get("liked_vegetables", []) +
                    data.get("liked_foods", [])  # Fallback para compatibilidad
                )
                
                profile_data = {
                    "peso": data["peso"],
                    "altura": data["altura"],
                    "edad": data["edad"],
                    "sexo": data["sexo"],
                    "objetivo": data["objetivo"],
                    "activity_factor": data["activity_factor"],
                    "exercise_data": exercise_data,
                    "enfoque_dietetico": data.get("enfoque_dietetico", "fitness"),  # Default fitness
                    "preferences": {
                        "liked_foods": all_liked_foods,
                        "liked_proteins": data.get("liked_proteins", []),
                        "liked_carbs": data.get("liked_carbs", []),
                        "liked_vegetables": data.get("liked_vegetables", []),
                        "disliked_foods": data.get("disliked_foods", []),
                        "special_restrictions": data.get("special_restrictions", []),
                        "cooking_methods": data.get("cooking_methods", ["horno", "sarten", "plancha"])
                    },
                    "variety_level": 3,  # Default
                    "cooking_schedule": "dos_sesiones",  # Default
                    "max_prep_time": 60  # Default
                }
                
                # Crear perfil usando el sistema cient√≠fico
                user_profile = meal_bot.profile_system.create_user_profile(telegram_id, profile_data)
                
                # Guardar en la base de datos
                meal_bot.data["users"][telegram_id] = user_profile
                meal_bot.save_data()
                
                # Limpiar estado de configuraci√≥n
                meal_bot.user_states[telegram_id] = {}
                
                # Mostrar resumen del perfil creado
                success_message = f"""
üéâ **¬°PERFIL NUTRICIONAL CREADO EXITOSAMENTE!**

üë§ **TU PERFIL CIENT√çFICO:**
‚Ä¢ Objetivo: {user_profile['basic_data']['objetivo_descripcion']}
‚Ä¢ BMR: {user_profile['body_composition']['bmr']} kcal/d√≠a
‚Ä¢ Available Energy: {user_profile['energy_data']['available_energy']} kcal/kg FFM/d√≠a
‚Ä¢ Estado: {user_profile['energy_data']['ea_status']['color']} {user_profile['energy_data']['ea_status']['description']}

üéØ **MACROS DIARIOS PERSONALIZADOS:**
üî• {user_profile['macros']['calories']} kcal totales
ü•© {user_profile['macros']['protein_g']}g prote√≠na
üçû {user_profile['macros']['carbs_g']}g carbohidratos  
ü•ë {user_profile['macros']['fat_g']}g grasas

üí° **RECOMENDACI√ìN CIENT√çFICA:**
{user_profile['energy_data']['ea_status']['recommendation']}

üöÄ **¬°YA PUEDES USAR EL SISTEMA V2.0!**

**Comandos disponibles:**
‚Ä¢ `/mis_macros` - Ver tu perfil completo
‚Ä¢ `/menu` - Men√∫ semanal con timing nutricional
‚Ä¢ `/buscar [consulta]` - Generar recetas con IA
‚Ä¢ `/generar` - Recetas espec√≠ficas por timing
‚Ä¢ `/complementos` - Ver complementos mediterr√°neos

¬°Tu alimentaci√≥n ahora est√° optimizada cient√≠ficamente! üß¨
"""
                
                meal_bot.send_long_message(
                    message.chat.id,
                    success_message,
                    parse_mode='Markdown',
                    reply_markup=meal_bot.create_main_menu_keyboard()
                )
                
            except Exception as e:
                bot.send_message(
                    message.chat.id,
                    f"‚ùå Error creando el perfil: {str(e)}\n\n"
                    "Por favor, intenta de nuevo con /perfil"
                )
        
    except ValueError as e:
        bot.send_message(
            message.chat.id,
            f"‚ùå Error: {str(e)}\n\n"
            "Por favor, introduce un valor v√°lido."
        )

def process_profile_edit(telegram_id: str, message):
    """Procesar edici√≥n de preferencias del perfil"""
    user_state = meal_bot.user_states.get(telegram_id, {})
    step = user_state.get("step")
    edit_section = user_state.get("edit_section")
    data = user_state.get("data", {})
    
    text = message.text.strip()
    
    # Verificar si quiere continuar
    if "continuar" in text.lower() or text == "‚û°Ô∏è Continuar":
        # Finalizar edici√≥n y guardar cambios
        save_profile_edit_changes(telegram_id, edit_section, data)
        return
    
    # Procesar seg√∫n secci√≥n de edici√≥n
    if step == "9C" and edit_section == "liked_foods":
        process_edit_liked_foods(telegram_id, message, data)
    elif step == "9D" and edit_section == "disliked_foods":
        process_edit_disliked_foods(telegram_id, message, data)
    elif step == "9F" and edit_section == "cooking_methods":
        process_edit_cooking_methods(telegram_id, message, data)
    elif step == "7" and edit_section == "training_schedule":
        process_edit_training_schedule(telegram_id, message, data)

def process_edit_liked_foods(telegram_id: str, message, data):
    """Procesar edici√≥n de alimentos preferidos"""
    text = message.text.strip()
    
    # Mapear opciones a IDs
    food_mapping = {
        "ü•© Carnes rojas": "carnes_rojas",
        "üêî Aves": "aves", 
        "üêü Pescados": "pescados",
        "ü•ö Huevos": "huevos",
        "ü•õ L√°cteos": "lacteos",
        "ü•ú Frutos secos": "frutos_secos",
        "ü´ò Legumbres": "legumbres",
        "ü•¨ Hojas verdes": "hojas_verdes",
        "ü•¶ Cruc√≠feras": "cruciferas",
        "üçÖ Solan√°ceas": "solanaceas",
        "üåø Arom√°ticas": "aromaticas",
        "ü•ï Ra√≠ces": "raices",
        "üå∂Ô∏è Pimientos": "pimientos",
        "ü•í Pepin√°ceas": "pepinaceas",
        "ü´í Aceitunas": "aceitunas",
        "ü•ë Aguacate": "aguacate"
    }
    
    if text in food_mapping:
        selected = food_mapping[text]
        
        # Inicializar lista si no existe
        if "liked_foods" not in data:
            data["liked_foods"] = []
        
        # Agregar si no est√° ya incluido
        if selected not in data["liked_foods"]:
            data["liked_foods"].append(selected)
            
        # Mostrar selecci√≥n actual
        selected_names = [name.replace("_", " ").title() for name in data["liked_foods"]]
        selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
        
        bot.send_message(
            message.chat.id,
            f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido\n\n"
            f"**Seleccionados:** {selection_text}\n\n"
            "Puedes seleccionar m√°s opciones o usar **‚û°Ô∏è Continuar** para finalizar.",
            parse_mode='Markdown'
        )
        
        # Actualizar estado
        meal_bot.user_states[telegram_id]["data"] = data
    else:
        bot.send_message(
            message.chat.id,
            "‚ùå Opci√≥n no v√°lida. Selecciona una de las opciones del teclado o usa **‚û°Ô∏è Continuar**.",
            parse_mode='Markdown'
        )

def process_edit_disliked_foods(telegram_id: str, message, data):
    """Procesar edici√≥n de alimentos a evitar"""
    text = message.text.strip()
    
    # Mapear opciones a IDs (mismo mapeo que liked_foods)
    food_mapping = {
        "ü•© Carnes rojas": "carnes_rojas",
        "üêî Aves": "aves", 
        "üêü Pescados": "pescados",
        "ü•ö Huevos": "huevos",
        "ü•õ L√°cteos": "lacteos",
        "ü•ú Frutos secos": "frutos_secos",
        "ü´ò Legumbres": "legumbres",
        "ü•¨ Hojas verdes": "hojas_verdes",
        "ü•¶ Cruc√≠feras": "cruciferas",
        "üçÖ Solan√°ceas": "solanaceas",
        "üåø Arom√°ticas": "aromaticas",
        "ü•ï Ra√≠ces": "raices",
        "üå∂Ô∏è Pimientos": "pimientos",
        "ü•í Pepin√°ceas": "pepinaceas",
        "ü´í Aceitunas": "aceitunas",
        "ü•ë Aguacate": "aguacate"
    }
    
    if text in food_mapping:
        selected = food_mapping[text]
        
        # Inicializar lista si no existe
        if "disliked_foods" not in data:
            data["disliked_foods"] = []
        
        # Agregar si no est√° ya incluido
        if selected not in data["disliked_foods"]:
            data["disliked_foods"].append(selected)
            
        # Mostrar selecci√≥n actual
        selected_names = [name.replace("_", " ").title() for name in data["disliked_foods"]]
        selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
        
        bot.send_message(
            message.chat.id,
            f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido a evitar\n\n"
            f"**A evitar:** {selection_text}\n\n"
            "Puedes seleccionar m√°s opciones o usar **‚û°Ô∏è Continuar** para finalizar.",
            parse_mode='Markdown'
        )
        
        # Actualizar estado
        meal_bot.user_states[telegram_id]["data"] = data
    else:
        bot.send_message(
            message.chat.id,
            "‚ùå Opci√≥n no v√°lida. Selecciona una de las opciones del teclado o usa **‚û°Ô∏è Continuar**.",
            parse_mode='Markdown'
        )

def process_edit_cooking_methods(telegram_id: str, message, data):
    """Procesar edici√≥n de m√©todos de cocci√≥n"""
    text = message.text.strip()
    
    # Mapear opciones a IDs
    cooking_mapping = {
        "üî• Horno": "horno",
        "üç≥ Sart√©n": "sarten",
        "ü•ò Plancha": "plancha",
        "ü´ï Vapor": "vapor",
        "ü•ó Crudo/Ensaladas": "crudo",
        "üç≤ Guisado": "guisado",
        "üî• Parrilla": "parrilla",
        "ü•Ñ Hervido": "hervido"
    }
    
    if text in cooking_mapping:
        selected = cooking_mapping[text]
        
        # Inicializar lista si no existe
        if "cooking_methods" not in data:
            data["cooking_methods"] = []
        
        # Agregar si no est√° ya incluido
        if selected not in data["cooking_methods"]:
            data["cooking_methods"].append(selected)
            
        # Mostrar selecci√≥n actual
        selected_names = [name.replace("_", " ").title() for name in data["cooking_methods"]]
        selection_text = ", ".join(selected_names) if selected_names else "Ninguna"
        
        bot.send_message(
            message.chat.id,
            f"‚úÖ **{selected.replace('_', ' ').title()}** a√±adido\n\n"
            f"**M√©todos seleccionados:** {selection_text}\n\n"
            "Puedes seleccionar m√°s opciones o usar **‚û°Ô∏è Continuar** para finalizar.",
            parse_mode='Markdown'
        )
        
        # Actualizar estado
        meal_bot.user_states[telegram_id]["data"] = data
    else:
        bot.send_message(
            message.chat.id,
            "‚ùå Opci√≥n no v√°lida. Selecciona una de las opciones del teclado o usa **‚û°Ô∏è Continuar**.",
            parse_mode='Markdown'
        )

def process_edit_training_schedule(telegram_id: str, message, data):
    """Procesar edici√≥n de horario de entrenamiento"""
    text = message.text.strip()
    
    # Mapear opciones a IDs
    schedule_mapping = {
        "üåÖ Ma√±ana (6:00-12:00)": {"id": "ma√±ana", "desc": "Ma√±ana (6:00-12:00)"},
        "‚òÄÔ∏è Mediod√≠a (12:00-16:00)": {"id": "mediodia", "desc": "Mediod√≠a (12:00-16:00)"},
        "üåÜ Tarde (16:00-20:00)": {"id": "tarde", "desc": "Tarde (16:00-20:00)"},
        "üåô Noche (20:00-24:00)": {"id": "noche", "desc": "Noche (20:00-24:00)"},
        "üîÑ Variable/Cambia": {"id": "variable", "desc": "Variable/Cambia"}
    }
    
    if text in schedule_mapping:
        selected = schedule_mapping[text]
        data["training_schedule"] = selected["id"]
        data["training_schedule_desc"] = selected["desc"]
        
        # Guardar inmediatamente
        save_profile_edit_changes(telegram_id, "training_schedule", data)
    else:
        bot.send_message(
            message.chat.id,
            "‚ùå Opci√≥n no v√°lida. Selecciona una de las opciones del teclado.",
            parse_mode='Markdown'
        )

def save_profile_edit_changes(telegram_id: str, edit_section: str, data):
    """Guardar cambios de edici√≥n en el perfil del usuario"""
    try:
        user_profile = meal_bot.get_user_profile(telegram_id)
        if not user_profile:
            bot.send_message(
                telegram_id,
                "‚ùå Error: No se pudo encontrar tu perfil."
            )
            return
        
        # Actualizar seg√∫n secci√≥n editada
        if edit_section == "liked_foods":
            user_profile["preferences"]["liked_foods"] = data.get("liked_foods", [])
            updated_section = "Alimentos preferidos"
            
        elif edit_section == "disliked_foods":
            user_profile["preferences"]["disliked_foods"] = data.get("disliked_foods", [])
            updated_section = "Alimentos a evitar"
            
        elif edit_section == "cooking_methods":
            user_profile["preferences"]["cooking_methods"] = data.get("cooking_methods", [])
            updated_section = "M√©todos de cocci√≥n"
            
        elif edit_section == "training_schedule":
            user_profile["exercise_profile"]["training_schedule"] = data.get("training_schedule", "variable")
            user_profile["exercise_profile"]["training_schedule_desc"] = data.get("training_schedule_desc", "Variable/Cambia")
            
            # Recalcular timing din√°mico de comidas
            objetivo = user_profile["basic_data"]["objetivo"]
            new_timing = meal_bot.profile_system.get_dynamic_meal_timing(
                data["training_schedule"], 
                objetivo
            )
            user_profile["exercise_profile"]["dynamic_meal_timing"] = new_timing
            updated_section = "Horario de entrenamiento"
        
        # Guardar cambios en base de datos
        meal_bot.data["users"][telegram_id] = user_profile
        meal_bot.save_data()
        
        # Limpiar estado de edici√≥n
        meal_bot.user_states[telegram_id] = {}
        
        # Confirmar cambios
        bot.send_message(
            telegram_id,
            f"‚úÖ **¬°{updated_section} actualizado exitosamente!**\n\n"
            f"Tus preferencias han sido guardadas y se aplicar√°n en:\n"
            f"‚Ä¢ Generaci√≥n de recetas con IA\n"
            f"‚Ä¢ Men√∫s personalizados\n"
            f"‚Ä¢ Complementos recomendados\n\n"
            f"üí° Usa `/mis_macros` para ver tu perfil actualizado.",
            parse_mode='Markdown',
            reply_markup=meal_bot.create_main_menu_keyboard()
        )
        
    except Exception as e:
        bot.send_message(
            telegram_id,
            f"‚ùå Error al guardar cambios: {str(e)}\n\n"
            f"Por favor, intenta de nuevo."
        )
        # Limpiar estado en caso de error
        meal_bot.user_states[telegram_id] = {}

def process_ai_search(telegram_id: str, query: str, message):
    """Procesar b√∫squeda con IA completamente funcional"""
    
    user_profile = meal_bot.get_user_profile(telegram_id)
    if not user_profile:
        bot.send_message(
            message.chat.id,
            "‚ùå **Error:** Necesitas configurar tu perfil primero.\n"
            "Usa /perfil para comenzar.",
            parse_mode='Markdown'
        )
        return
    
    try:
        # Generar recetas con IA
        result = meal_bot.ai_generator.search_and_adapt_recipes(user_profile, query)
        
        if result["success"]:
            results = result["results"]
            total_found = result["total_found"]
            
            if total_found == 0:
                bot.send_message(
                    message.chat.id,
                    f"üîç **B√∫squeda: '{query}'**\n\n"
                    "‚ùå No se encontraron recetas que cumplan tus criterios.\n\n"
                    "üí° **Sugerencias:**\n"
                    "‚Ä¢ Intenta t√©rminos m√°s generales (ej: 'pollo' en lugar de 'pollo al curry')\n"
                    "‚Ä¢ Especifica el timing (ej: 'post entreno')\n"
                    "‚Ä¢ Menciona ingredientes principales\n\n"
                    "**Ejemplos exitosos:**\n"
                    "‚Ä¢ `/buscar proteina post entreno`\n"
                    "‚Ä¢ `/buscar legumbres mediterraneas`\n"
                    "‚Ä¢ `/buscar desayuno alto carbohidratos`",
                    parse_mode='Markdown'
                )
                return
            
            # Mostrar resultados encontrados
            intro_text = f"""
ü§ñ **B√öSQUEDA COMPLETADA CON IA**

**Tu consulta:** '{query}'
‚úÖ **Encontradas:** {total_found} recetas v√°lidas
üìä **Adaptadas** a tu perfil nutricional

üéØ **Tu objetivo:** {user_profile['basic_data']['objetivo_descripcion']}
üî• **Tus macros:** {user_profile['macros']['calories']} kcal diarias

**RECETAS GENERADAS:**
"""
            
            meal_bot.send_long_message(message.chat.id, intro_text, parse_mode='Markdown')
            
            # Mostrar cada receta encontrada
            for i, recipe_result in enumerate(results[:3], 1):  # M√°ximo 3 recetas
                recipe = recipe_result.get("adaptacion_propuesta")
                validation = recipe_result.get("validation", {})
                changes = recipe_result.get("cambios_realizados", [])
                
                if recipe:
                    # Formatear receta para display
                    recipe_text = format_recipe_for_display(recipe, validation)
                    
                    # Agregar informaci√≥n de cambios
                    if changes:
                        recipe_text += f"\n\nüîß **Adaptaciones realizadas:**\n"
                        for change in changes:
                            recipe_text += f"‚Ä¢ {change}\n"
                    
                    # Enviar receta
                    meal_bot.send_long_message(
                        message.chat.id, 
                        f"**OPCI√ìN {i}:**\n{recipe_text}",
                        parse_mode='Markdown'
                    )
            
            # Crear botones para seleccionar recetas
            keyboard = types.InlineKeyboardMarkup(row_width=3)
            
            # Botones para cada receta encontrada
            recipe_buttons = []
            for i in range(len(results[:3])):
                recipe_buttons.append(
                    types.InlineKeyboardButton(f"‚úÖ Receta {i+1}", callback_data=f"select_search_recipe_{i}")
                )
            
            keyboard.add(*recipe_buttons)
            keyboard.add(
                types.InlineKeyboardButton("üîÑ M√°s opciones", callback_data=f"more_search_options_{query}"),
                types.InlineKeyboardButton("üóìÔ∏è Men√∫ completo", callback_data="theme_auto")
            )
            
            # Guardar resultados en el estado del usuario para poder seleccionarlos
            meal_bot.user_states[telegram_id] = {
                "state": "search_results",
                "query": query,
                "results": results[:3],
                "step": "selection"
            }
            
            # Opciones de seguimiento
            followup_text = f"""
üéØ **SELECCIONA UNA RECETA:**

Puedes elegir cualquiera de las recetas mostradas arriba o buscar m√°s opciones.

üí° **Tip:** Todas las recetas est√°n validadas con ingredientes naturales y ajustadas a tus macros objetivo.
"""
            
            bot.send_message(
                message.chat.id, 
                followup_text, 
                parse_mode='Markdown',
                reply_markup=keyboard
            )
            
        else:
            # Error en la generaci√≥n
            error_msg = result.get("error", "Error desconocido")
            bot.send_message(
                message.chat.id,
                f"‚ùå **Error en la b√∫squeda:**\n{error_msg}\n\n"
                "üí° **Intenta:**\n"
                "‚Ä¢ Reformular tu consulta\n"
                "‚Ä¢ Usar t√©rminos m√°s espec√≠ficos\n"
                "‚Ä¢ Verificar tu conexi√≥n a internet\n\n"
                "Si el problema persiste, contacta al administrador.",
                parse_mode='Markdown'
            )
            
    except Exception as e:
        logger.error(f"Error in AI search: {e}")
        bot.send_message(
            message.chat.id,
            "‚ùå **Error t√©cnico** procesando tu b√∫squeda.\n"
            "Int√©ntalo de nuevo en unos momentos.",
            parse_mode='Markdown'
        )
    
    # Limpiar estado
    meal_bot.user_states[telegram_id] = {}

# ========================================
# MANEJADOR DE MENSAJES DE TEXTO
# ========================================

@bot.message_handler(func=lambda message: True)
def handle_text_messages(message):
    """Manejar todos los mensajes de texto seg√∫n el estado del usuario"""
    telegram_id = str(message.from_user.id)
    user_state = meal_bot.user_states.get(telegram_id, {})
    
    if user_state.get("state") == "profile_setup":
        process_profile_setup(telegram_id, message)
    elif user_state.get("state") == "profile_edit":
        process_profile_edit(telegram_id, message)
    elif user_state.get("state") == "schedule_setup":
        process_schedule_setup(telegram_id, message)
    elif user_state.get("state") == "shopping_list_setup":
        process_shopping_list_setup(telegram_id, message)
    elif user_state.get("state") == "ai_search":
        # B√∫squeda ya procesada
        pass
    elif user_state.get("state") == "metric_entry":
        process_metric_entry(telegram_id, message)
    else:
        # Mensaje libre - responder con ayuda personalizada
        user_profile = meal_bot.get_user_profile(telegram_id)
        
        if user_profile:
            # Usuario con perfil - mostrar comandos personalizados
            preferences = user_profile.get("preferences", {})
            liked_count = len(preferences.get("liked_foods", []))
            disliked_count = len(preferences.get("disliked_foods", []))
            
            help_text = f"""
‚ú® **COMANDOS PERSONALIZADOS PARA TI**

üë§ **Tu perfil:** {user_profile['basic_data']['objetivo_descripcion']}
üéØ **Personalizaci√≥n activa:** {liked_count} preferencias, {disliked_count} exclusiones

**COMANDOS PRINCIPALES:**
‚úÖ /mis_macros - Ver tus macros personalizados
‚úÖ /menu - Men√∫ semanal adaptado a tus preferencias  
‚úÖ /complementos - Complementos filtrados para ti
‚úÖ /favoritas - Ver tus recetas guardadas
‚úÖ /lista_compras - Lista optimizada para tu perfil

**GENERACI√ìN IA:**
ü§ñ /generar - Recetas espec√≠ficas para tu objetivo
üîç /buscar [consulta] - Buscar con IA personalizada

**CONFIGURACI√ìN:**
‚öôÔ∏è /editar_perfil - Modificar preferencias
üìÖ /nueva_semana - Configurar cronograma

üí° **Todo se adapta autom√°ticamente a tu perfil nutricional**
"""
        else:
            # Usuario sin perfil
            help_text = """
‚ùì **COMANDOS DISPONIBLES:**

‚ö†Ô∏è **Primero configura tu perfil para personalizaci√≥n completa:**
üÜï /perfil - Configurar perfil nutricional

**COMANDOS B√ÅSICOS:**
/menu - Men√∫ semanal gen√©rico
/recetas - Explorar recetas
/complementos - Ver complementos
/buscar [consulta] - Buscar recetas con IA
/generar - Generar receta espec√≠fica

üí° **¬°Configura tu perfil para experiencia 100% personalizada!**
"""
        
        bot.send_message(message.chat.id, help_text, parse_mode='Markdown')

def process_schedule_setup(telegram_id: str, message):
    """Procesar configuraci√≥n de cronograma"""
    user_state = meal_bot.user_states.get(telegram_id, {})
    choice = message.text.upper().strip()
    
    schedules = {
        "A": "sesion_unica_domingo",
        "B": "dos_sesiones", 
        "C": "tres_sesiones",
        "D": "preparacion_diaria"
    }
    
    if choice in schedules:
        schedule_id = schedules[choice]
        schedule_data = meal_bot.data["cooking_schedules"][schedule_id]
        
        # Guardar en perfil de usuario (cuando est√© implementado)
        # user_profile["settings"]["cooking_schedule"] = schedule_id
        
        bot.send_message(
            message.chat.id,
            f"‚úÖ **Cronograma seleccionado:** {schedule_data['name']}\n\n"
            f"üìù **Descripci√≥n:** {schedule_data['description']}\n"
            f"‚è±Ô∏è **Tiempo estimado:** {schedule_data['estimated_time']}\n\n"
            "üéØ **Pr√≥ximos pasos:**\n"
            "‚Ä¢ Usa /buscar para generar recetas espec√≠ficas\n"
            "‚Ä¢ Configura tu nivel de variedad semanal\n"
            "‚Ä¢ El sistema optimizar√° tu lista de compras\n\n"
            "**Tu cronograma se aplicar√° autom√°ticamente al generar men√∫s.**",
            parse_mode='Markdown',
            reply_markup=meal_bot.create_main_menu_keyboard()
        )
        
        # Limpiar estado
        meal_bot.user_states[telegram_id] = {}
        
    else:
        bot.send_message(
            message.chat.id,
            "‚ùå **Opci√≥n no v√°lida**\n\n"
            "Por favor responde con A, B, C o D seg√∫n tu preferencia."
        )

def process_shopping_list_setup(telegram_id: str, message):
    """Procesar configuraci√≥n de lista de compras"""
    user_state = meal_bot.user_states.get(telegram_id, {})
    choice = message.text.upper().strip()
    
    days_mapping = {
        "A": 3,
        "B": 5,
        "C": 7,
        "D": 10
    }
    
    if choice in days_mapping:
        days = days_mapping[choice]
        
        # Mostrar mensaje de procesamiento
        bot.send_message(
            message.chat.id,
            f"üõí **Generando lista de compras para {days} d√≠as...**\n\n"
            "‚è≥ Calculando cantidades seg√∫n tus macros...\n"
            "ü•ò Aplicando preferencias alimentarias...\n"
            "üåä A√±adiendo complementos mediterr√°neos...\n"
            "üì¶ Optimizando para meal prep...",
            parse_mode='Markdown'
        )
        
        try:
            # Obtener perfil del usuario
            user_profile = meal_bot.get_user_profile(telegram_id)
            
            # Generar lista de compras
            shopping_result = meal_bot.shopping_generator.generate_shopping_list(user_profile, days)
            
            if shopping_result["success"]:
                # Formatear y enviar lista
                shopping_text = meal_bot.shopping_generator.format_shopping_list_for_telegram(
                    shopping_result, user_profile
                )
                
                meal_bot.send_long_message(message.chat.id, shopping_text, parse_mode='Markdown')
                
                # Mensaje de confirmaci√≥n
                confirmation_text = f"""
‚úÖ **LISTA GENERADA EXITOSAMENTE**

üõí Lista optimizada para {days} d√≠as de meal prep
üìä {shopping_result['metadata']['daily_calories']} kcal diarios
‚ú® Adaptada a tus preferencias alimentarias

üí° **PR√ìXIMOS PASOS:**
‚Ä¢ Guarda esta lista en tu m√≥vil
‚Ä¢ Ve al supermercado con la lista
‚Ä¢ Sigue los consejos de meal prep
‚Ä¢ Usa `/menu` para ver tu men√∫ semanal
‚Ä¢ Genera recetas espec√≠ficas con `/generar`

**¬°Lista personalizada 100% para tu perfil!**
"""
                
                bot.send_message(message.chat.id, confirmation_text, parse_mode='Markdown')
                
            else:
                bot.send_message(
                    message.chat.id,
                    f"‚ùå **Error generando lista:**\n{shopping_result.get('error', 'Error desconocido')}\n\n"
                    "üí° **Intenta:**\n"
                    "‚Ä¢ Usar `/lista_compras` de nuevo\n"
                    "‚Ä¢ Verificar que tu perfil est√© completo\n"
                    "‚Ä¢ Contactar soporte si persiste el error",
                    parse_mode='Markdown'
                )
        
        except Exception as e:
            bot.send_message(
                message.chat.id,
                f"‚ùå **Error procesando solicitud:**\n{str(e)}\n\n"
                "üí° Intenta usar `/lista_compras` de nuevo",
                parse_mode='Markdown'
            )
        
        # Limpiar estado del usuario
        meal_bot.user_states[telegram_id] = {}
        
    else:
        bot.send_message(
            message.chat.id,
            "‚ùå **Opci√≥n no v√°lida**\n\n"
            "Por favor responde con A, B, C o D seg√∫n la duraci√≥n deseada."
        )

def process_metric_entry(telegram_id: str, message):
    """Procesar entrada de m√©tricas del usuario"""
    user_state = meal_bot.user_states.get(telegram_id, {})
    metric_name = user_state.get("metric_name")
    step = user_state.get("step", "value")
    
    if not metric_name:
        bot.send_message(message.chat.id, "‚ùå Error: No se encontr√≥ la m√©trica a registrar")
        meal_bot.user_states[telegram_id] = {}
        return
    
    if step == "value":
        try:
            # Extraer valor num√©rico del mensaje
            text = message.text.strip()
            
            # Separar valor de notas opcionales
            parts = text.split(' ', 1)
            value_str = parts[0]
            notes = parts[1] if len(parts) > 1 else ""
            
            # Convertir a float
            try:
                value = float(value_str.replace(',', '.'))
            except ValueError:
                raise ValueError("Valor no num√©rico v√°lido")
            
            # Obtener configuraci√≥n de la m√©trica
            metric_config = meal_bot.progress_tracker.trackable_metrics.get(metric_name, {})
            min_val = metric_config.get("min_value", 0)
            max_val = metric_config.get("max_value", 100)
            
            # Validar rango
            if not (min_val <= value <= max_val):
                bot.send_message(
                    message.chat.id,
                    f"‚ùå **Valor fuera de rango**\n\n"
                    f"üìä **{metric_config.get('name', 'M√©trica')}** debe estar entre "
                    f"{min_val} y {max_val} {metric_config.get('unit', '')}\n\n"
                    f"üí° Env√≠a un valor v√°lido o usa /progreso para cancelar",
                    parse_mode='Markdown'
                )
                return
            
            # Registrar m√©trica
            user_profile = meal_bot.get_user_profile(telegram_id)
            if not user_profile:
                bot.send_message(message.chat.id, "‚ùå Error: No se encontr√≥ tu perfil")
                meal_bot.user_states[telegram_id] = {}
                return
            
            # Mostrar mensaje de procesamiento
            processing_msg = bot.send_message(
                message.chat.id,
                f"üìä **Registrando {metric_config.get('name', 'm√©trica')}...**\n\n"
                "üìà Guardando datos\n"
                "üéØ Calculando tendencias\n"
                "üí° Generando insights\n\n"
                "*Esto puede tomar unos segundos...*",
                parse_mode='Markdown'
            )
            
            # Registrar la m√©trica
            result = meal_bot.progress_tracker.record_metric(user_profile, metric_name, value, notes)
            
            # Eliminar mensaje de procesamiento
            bot.delete_message(message.chat.id, processing_msg.message_id)
            
            if result["success"]:
                # Guardar perfil actualizado
                meal_bot.database.save_user_profile(telegram_id, user_profile)
                
                # Formatear respuesta de √©xito
                metric_recorded = result["metric_recorded"]
                trend_analysis = result["trend_analysis"]
                insights = result.get("insights", [])
                
                success_text = f"""
‚úÖ **M√âTRICA REGISTRADA EXITOSAMENTE**

üìä **{metric_recorded['name']}:** {metric_recorded['value']}{metric_recorded['unit']}
üìÖ **Fecha:** {metric_recorded['date']}
üìà **Total registros:** {result['total_records']}

üéØ **AN√ÅLISIS DE TENDENCIA:**
‚Ä¢ **Estado:** {trend_analysis['trend_description']}
‚Ä¢ **Cambio semanal:** {trend_analysis['change_rate']:+.2f}{metric_recorded['unit']}/semana
‚Ä¢ **Datos analizados:** {trend_analysis['data_points']} puntos en {trend_analysis['period_analyzed']}
"""
                
                # A√±adir insights si existen
                if insights:
                    success_text += "\nüí° **INSIGHTS PERSONALIZADOS:**\n"
                    for insight in insights:
                        success_text += f"‚Ä¢ {insight}\n"
                
                # A√±adir pr√≥ximos pasos
                success_text += f"""

üöÄ **PR√ìXIMOS PASOS:**
‚Ä¢ Contin√∫a registrando m√©tricas regularmente
‚Ä¢ Usa `/progreso` para ver reportes completos
‚Ä¢ Las recomendaciones se ajustan autom√°ticamente
‚Ä¢ Tu Available Energy se actualiza con cambios de peso

**¬°El sistema aprende continuamente de tus datos!**
"""
                
                meal_bot.send_long_message(
                    message.chat.id,
                    success_text,
                    parse_mode='Markdown'
                )
                
                # Botones de acciones r√°pidas
                keyboard = types.InlineKeyboardMarkup(row_width=2)
                keyboard.add(
                    types.InlineKeyboardButton("üìä Ver Reporte", callback_data="progress_report"),
                    types.InlineKeyboardButton("üìà Registrar Otra", callback_data="progress_record")
                )
                
                bot.send_message(
                    message.chat.id,
                    "üéØ **¬øQu√© quieres hacer ahora?**",
                    parse_mode='Markdown',
                    reply_markup=keyboard
                )
                
            else:
                bot.send_message(
                    message.chat.id,
                    f"‚ùå **Error registrando m√©trica:**\n{result.get('error', 'Error desconocido')}\n\n"
                    "üí° Intenta de nuevo o usa `/progreso` para volver al men√∫ principal",
                    parse_mode='Markdown'
                )
            
            # Limpiar estado
            meal_bot.user_states[telegram_id] = {}
            
        except ValueError as e:
            bot.send_message(
                message.chat.id,
                f"‚ùå **Formato no v√°lido**\n\n"
                f"üìù **Env√≠a solo el n√∫mero** (ejemplo: 75.2)\n"
                f"üí° Opcionalmente puedes a√±adir notas despu√©s del n√∫mero\n\n"
                f"**Ejemplos v√°lidos:**\n"
                f"‚Ä¢ `75.2`\n"
                f"‚Ä¢ `75.2 despu√©s del entreno`\n"
                f"‚Ä¢ `75,2 por la ma√±ana`\n\n"
                f"Usa `/progreso` para cancelar",
                parse_mode='Markdown'
            )
            
        except Exception as e:
            logger.error(f"Error processing metric entry: {e}")
            bot.send_message(
                message.chat.id,
                f"‚ùå **Error procesando m√©trica:**\n{str(e)}\n\n"
                "üí° Intenta de nuevo o usa `/progreso` para volver al men√∫",
                parse_mode='Markdown'
            )
            
            # Limpiar estado en caso de error
            meal_bot.user_states[telegram_id] = {}

# ========================================
# CONFIGURACI√ìN WEBHOOK/POLLING
# ========================================

@app.route(WEBHOOK_PATH, methods=['POST'])
def webhook():
    """Webhook endpoint para Railway"""
    if request.headers.get('content-type') == 'application/json':
        json_string = request.get_data().decode('utf-8')
        update = telebot.types.Update.de_json(json_string)
        bot.process_new_updates([update])
        return ''
    else:
        return 'Invalid content type', 400

def setup_webhook():
    """Configurar webhook si est√° habilitado"""
    if USE_WEBHOOK and WEBHOOK_URL:
        webhook_url = f"{WEBHOOK_URL}{WEBHOOK_PATH}"
        bot.set_webhook(url=webhook_url)
        logger.info(f"‚úÖ Webhook configurado: {webhook_url}")
        return True
    return False

# ========================================
# CALLBACK HANDLERS - WEEKLY MENU CONFIGURATION
# ========================================

@bot.callback_query_handler(func=lambda call: call.data.startswith('menu_select_'))
def handle_menu_recipe_selection(call):
    """Manejar selecci√≥n de recetas para el men√∫ semanal"""
    telegram_id = str(call.from_user.id)
    
    try:
        # Extraer datos del callback
        parts = call.data.split('_')
        category = parts[2]  # desayuno, almuerzo, merienda, cena
        recipe_id = parts[3]
        
        # Obtener perfil del usuario
        user_profile = meal_bot.database.get_user_profile(telegram_id)
        if not user_profile:
            bot.answer_callback_query(call.id, "‚ùå Perfil no encontrado. Usa /perfil primero.")
            return
        
        # Inicializar configuraci√≥n del men√∫ si no existe
        if "temp_menu_config" not in user_profile:
            user_profile["temp_menu_config"] = {}
        
        if "selected_recipes" not in user_profile["temp_menu_config"]:
            user_profile["temp_menu_config"]["selected_recipes"] = {
                "desayuno": [],
                "almuerzo": [],
                "merienda": [],
                "cena": []
            }
        
        # Agregar la receta seleccionada
        selected_recipes = user_profile["temp_menu_config"]["selected_recipes"]
        if recipe_id not in selected_recipes[category]:
            selected_recipes[category].append(recipe_id)
            
            # Obtener nombre de la receta para confirmaci√≥n
            available_recipes = meal_bot.weekly_menu_system.get_user_saved_recipes(user_profile)
            recipe_name = "Receta seleccionada"
            for recipe in available_recipes.get(category, []):
                if recipe["id"] == recipe_id:
                    recipe_name = recipe["name"]
                    break
            
            bot.answer_callback_query(call.id, f"‚úÖ {recipe_name} agregada a {category.title()}")
        else:
            bot.answer_callback_query(call.id, "‚ö†Ô∏è Esta receta ya est√° seleccionada para esta categor√≠a")
        
        # Guardar cambios
        meal_bot.database.save_user_profile(telegram_id, user_profile)
        
        # Actualizar el mensaje con la nueva selecci√≥n
        show_category_recipe_selection(call.message, telegram_id, category, edit_message=True)
        
    except Exception as e:
        logger.error(f"Error in menu recipe selection: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando selecci√≥n")

@bot.callback_query_handler(func=lambda call: call.data.startswith('menu_next_'))
def handle_menu_next_category(call):
    """Manejar avance a la siguiente categor√≠a del men√∫"""
    telegram_id = str(call.from_user.id)
    
    try:
        current_category = call.data.split('_')[2]
        next_category = get_next_category(current_category)
        
        if next_category:
            # Mostrar la siguiente categor√≠a
            show_category_recipe_selection(call.message, telegram_id, next_category, edit_message=True)
            bot.answer_callback_query(call.id, f"‚û°Ô∏è Configurando {next_category.title()}")
        else:
            # Todas las categor√≠as completadas, mostrar preview
            generate_menu_preview_step(call.message, telegram_id, edit_message=True)
            bot.answer_callback_query(call.id, "‚úÖ Configuraci√≥n completada")
            
    except Exception as e:
        logger.error(f"Error in menu next category: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error avanzando categor√≠a")

@bot.callback_query_handler(func=lambda call: call.data == 'menu_confirm')
def handle_menu_confirm(call):
    """Confirmar y guardar el men√∫ semanal configurado"""
    telegram_id = str(call.from_user.id)
    
    try:
        # Obtener perfil del usuario
        user_profile = meal_bot.database.get_user_profile(telegram_id)
        if not user_profile or "temp_menu_config" not in user_profile:
            bot.answer_callback_query(call.id, "‚ùå No hay configuraci√≥n de men√∫ temporal")
            return
        
        selected_recipes = user_profile["temp_menu_config"]["selected_recipes"]
        
        # Crear distribuci√≥n semanal
        weekly_menu = meal_bot.weekly_menu_system.create_weekly_distribution(selected_recipes, user_profile)
        
        # Guardar configuraci√≥n del men√∫
        config_id = meal_bot.weekly_menu_system.save_weekly_menu_configuration(
            telegram_id, weekly_menu, selected_recipes, user_profile
        )
        
        # Limpiar configuraci√≥n temporal
        del user_profile["temp_menu_config"]
        meal_bot.database.save_user_profile(telegram_id, user_profile)
        
        # Mensaje de confirmaci√≥n
        bot.edit_message_text(
            f"‚úÖ **MEN√ö SEMANAL GUARDADO**\n\n"
            f"üÜî **ID de configuraci√≥n:** `{config_id}`\n"
            f"üìÖ **Estado:** Listo para usar\n\n"
            f"üéØ **Pr√≥ximos pasos:**\n"
            f"‚Ä¢ Tu men√∫ est√° distribuido inteligentemente por 7 d√≠as\n"
            f"‚Ä¢ Recetas balanceadas seg√∫n tus macros objetivo\n"
            f"‚Ä¢ Evita repeticiones consecutivas autom√°ticamente\n\n"
            f"üí° **Comandos √∫tiles:**\n"
            f"‚Ä¢ `/generar` - Crear nuevas recetas espec√≠ficas\n"
            f"‚Ä¢ `/buscar [plato]` - Encontrar recetas adicionales\n"
            f"‚Ä¢ `/configurar_menu` - Crear otro men√∫ diferente\n\n"
            f"**¬°Tu meal prep semanal est√° listo!**",
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            parse_mode='Markdown'
        )
        
        bot.answer_callback_query(call.id, "üéâ Men√∫ guardado exitosamente")
        
    except Exception as e:
        logger.error(f"Error confirming menu: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error guardando men√∫")

@bot.callback_query_handler(func=lambda call: call.data == 'menu_edit')
def handle_menu_edit(call):
    """Volver a editar la configuraci√≥n del men√∫"""
    telegram_id = str(call.from_user.id)
    
    try:
        # Volver al primer paso de configuraci√≥n
        show_category_recipe_selection(call.message, telegram_id, "desayuno", edit_message=True)
        bot.answer_callback_query(call.id, "‚úèÔ∏è Editando configuraci√≥n")
        
    except Exception as e:
        logger.error(f"Error editing menu: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error editando men√∫")

@bot.callback_query_handler(func=lambda call: call.data == 'menu_save_config')
def handle_menu_save_config(call):
    """Guardar configuraci√≥n del men√∫ como plantilla"""
    telegram_id = str(call.from_user.id)
    
    try:
        # Obtener perfil del usuario
        user_profile = meal_bot.database.get_user_profile(telegram_id)
        if not user_profile or "temp_menu_config" not in user_profile:
            bot.answer_callback_query(call.id, "‚ùå No hay configuraci√≥n para guardar")
            return
        
        selected_recipes = user_profile["temp_menu_config"]["selected_recipes"]
        
        # Crear distribuci√≥n semanal
        weekly_menu = meal_bot.weekly_menu_system.create_weekly_distribution(selected_recipes, user_profile)
        
        # Guardar como configuraci√≥n guardada (no activa)
        config_id = meal_bot.weekly_menu_system.save_weekly_menu_configuration(
            telegram_id, weekly_menu, selected_recipes, user_profile
        )
        
        # Cambiar estado a 'draft' para indicar que es una plantilla
        for config in user_profile.get("weekly_menu_configs", []):
            if config["config_id"] == config_id:
                config["status"] = "draft"
                break
        
        meal_bot.database.save_user_profile(telegram_id, user_profile)
        
        bot.answer_callback_query(call.id, "üíæ Configuraci√≥n guardada como plantilla")
        
        # Actualizar mensaje
        bot.edit_message_text(
            f"üíæ **CONFIGURACI√ìN GUARDADA COMO PLANTILLA**\n\n"
            f"üÜî **ID:** `{config_id}`\n"
            f"üìã **Estado:** Plantilla guardada\n\n"
            f"üéØ **Opciones:**\n"
            f"‚Ä¢ Usa `/configurar_menu` para crear otra configuraci√≥n\n"
            f"‚Ä¢ Esta plantilla queda disponible para uso futuro\n"
            f"‚Ä¢ Puedes crear m√∫ltiples configuraciones diferentes\n\n"
            f"**¬°Plantilla guardada exitosamente!**",
            chat_id=call.message.chat.id,
            message_id=call.message.message_id,
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error saving menu config: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error guardando configuraci√≥n")

@bot.callback_query_handler(func=lambda call: call.data.startswith('approach_'))
def handle_approach_callback(call):
    """Manejar la selecci√≥n del enfoque diet√©tico"""
    telegram_id = str(call.from_user.id)
    
    # Verificar que el usuario est√© en el proceso de configuraci√≥n
    user_state = meal_bot.user_states.get(telegram_id)
    if not user_state or user_state.get("state") != "profile_setup" or user_state.get("step") != "enfoque_dietetico":
        bot.answer_callback_query(call.id, "‚ùå Sesi√≥n expirada. Usa /perfil para empezar de nuevo.")
        return
    
    try:
        # Procesar la selecci√≥n
        approach = call.data.split('_')[1]  # 'tradicional' o 'fitness'
        
        # Guardar el enfoque seleccionado
        user_state["data"]["enfoque_dietetico"] = approach
        
        # Avanzar al siguiente paso
        user_state["step"] = "peso"
        
        # Confirmar selecci√≥n y continuar
        approach_name = "üá™üá∏ Tradicional Espa√±ol" if approach == "tradicional" else "üí™ Fitness Orientado"
        bot.answer_callback_query(call.id, f"‚úÖ Enfoque seleccionado: {approach_name}")
        
        # Continuar con el flujo normal del perfil
        bot.send_message(
            call.message.chat.id,
            f"‚úÖ **Enfoque seleccionado:** {approach_name}\n\n"
            "Perfecto, ahora continuemos con tu informaci√≥n f√≠sica para calcular tus macros personalizados.\n\n"
            "üìè **Paso 1/9:** ¬øCu√°l es tu peso actual en kg?\n"
            "_(Ejemplo: 70)_",
            parse_mode='Markdown'
        )
        
    except Exception as e:
        logger.error(f"Error processing approach selection: {e}")
        bot.answer_callback_query(call.id, "‚ùå Error procesando selecci√≥n")

def main():
    """Funci√≥n principal"""
    logger.info("üöÄ Iniciando Meal Prep Bot V2.0...")
    
    try:
        # Intentar configurar webhook
        if not setup_webhook():
            logger.info("üì± Iniciando en modo polling...")
            bot.remove_webhook()
            bot.polling(none_stop=True, interval=1, timeout=60)
        else:
            logger.info("üåê Iniciando servidor webhook...")
            # En Railway, el puerto se obtiene de la variable de entorno
            port = int(os.environ.get('PORT', 5000))
            app.run(host='0.0.0.0', port=port, debug=False)
            
    except Exception as e:
        logger.error(f"‚ùå Error al iniciar el bot: {e}")
        raise

if __name__ == "__main__":
    main()